<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title>EQS - ブラウザで動くリアルタイム地震波伝播シミュレーター</title>
    
    <meta name="description" content="ブラウザ上で動作する物理演算ベースの地震シミュレーター。P波・S波の伝播、地盤増幅率（AVS30）を考慮した震度計算、過去の巨大地震の再現などをブラウザ上でリアルタイムに可視化します。">
    
    <meta name="keywords" content="地震,シミュレーター,地震波,緊急地震速報,強震モニタ,南海トラフ,東日本大震災,ブラウザ">

    <meta property="og:title" content="EQS - 地震波伝播シミュレーター">
    <meta property="og:description" content="ブラウザ上で動作する物理演算ベースのリアルタイム地震シミュレーター。">
    <meta property="og:url" content="https://skotm.github.io/eqs---Earthquake-Simulator-/">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=Roboto+Mono:wght@400;500;700&family=Roboto:wght@700;900&family=Noto+Sans+JP:wght@500;700;900&display=swap" rel="stylesheet">
    <style>
        /* --- 基本スタイル --- */
        body { margin: 0; overflow: hidden; background-color: #050507; font-family: "Noto Sans JP", sans-serif; touch-action: none; user-select: none; color: #fff; }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; }
        .interactive { pointer-events: auto; }

        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #020203; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #00aaff; font-family: monospace; z-index: 9999; transition: opacity 0.5s; pointer-events: auto; }
        .loader { border: 2px solid #111; border-top: 2px solid #00aaff; border-radius: 50%; width: 30px; height: 30px; animation: spin 0.8s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* コンパクト・インフォメーションバー */
        #info-bar {
            position: absolute; top: 8px; left: 8px; 
            width: fit-content; max-width: calc(100% - 16px);
            height: 24px;
            background: linear-gradient(135deg, rgba(10, 12, 16, 0.92), rgba(15, 18, 25, 0.88));
            border: 1px solid rgba(51, 51, 51, 0.6);
            border-left: 3px solid #00aaff;
            border-radius: 6px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 12px;
            backdrop-filter: blur(12px);
            font-family: "Roboto Mono", monospace;
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(0, 170, 255, 0.15);
            transition: all 0.3s ease;
            overflow: hidden;
            white-space: nowrap;
        }
        #info-bar.warning {
            border-left-color: #ff1744;
            background: linear-gradient(135deg, rgba(60, 10, 10, 0.95), rgba(40, 10, 10, 0.92));
            animation: borderFlash 1s infinite alternate;
        }
        @keyframes borderFlash { from { border-left-color: #ff1744; box-shadow: 0 0 8px #ff1744, 0 4px 16px rgba(0,0,0,0.6); } to { border-left-color: #b71c1c; box-shadow: 0 0 20px #ff1744, 0 4px 20px rgba(255, 23, 68, 0.4); } }

        .ib-item { display: flex; align-items: center; gap: 4px; font-size: 0.75rem; }
        .ib-label { color: #888; font-size: 0.65rem; font-weight: bold; }
        .ib-val { color: #fff; font-weight: bold; font-family: "Noto Sans JP", sans-serif; }
        .ib-val.warn { color: #ffeb3b; font-family: "Oswald", sans-serif; }
        
        #clock { font-size: 0.8rem; letter-spacing: 0.5px; color: #ccc; font-family: "Roboto Mono"; font-weight: bold; }
        .separator { width: 1px; height: 12px; background: linear-gradient(to bottom, transparent, #555, transparent); }

        .mode-badge { position: absolute; top: 8px; right: 8px; background: linear-gradient(135deg, rgba(0, 255, 128, 0.15), rgba(0, 200, 100, 0.1)); border: 1px solid rgba(0, 255, 128, 0.4); color: #00ff80; padding: 3px 8px; font-size: 0.65rem; font-family: "Oswald"; border-radius: 4px; pointer-events: none; backdrop-filter: blur(8px); box-shadow: 0 2px 8px rgba(0, 255, 128, 0.2); z-index: 1001; }

        #bottom-nav { position: absolute; bottom: 0; left: 0; width: 100%; height: 60px; background: linear-gradient(to top, rgba(10, 12, 16, 0.98), rgba(15, 18, 22, 0.95)); border-top: 1px solid rgba(0, 170, 255, 0.2); display: flex; z-index: 1000; backdrop-filter: blur(16px); padding-bottom: env(safe-area-inset-bottom); box-shadow: 0 -4px 20px rgba(0,0,0,0.5); }
        .nav-btn { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #666; cursor: pointer; transition: all 0.3s ease; border: none; background: none; padding: 5px 0; position: relative; }
        .nav-btn.active { color: #00aaff; text-shadow: 0 0 8px rgba(0, 170, 255, 0.6); }
        .nav-btn.active::after { content: ''; position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 40%; height: 3px; background: linear-gradient(90deg, transparent, #00aaff, transparent); box-shadow: 0 0 12px rgba(0, 170, 255, 0.8), 0 0 20px rgba(0, 170, 255, 0.4); }
        .nav-icon { width: 20px; height: 20px; margin-bottom: 5px; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; }
        .nav-icon svg { width: 100%; height: 100%; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .nav-btn:hover .nav-icon { transform: scale(1.1); }
        .nav-btn.active .nav-icon { transform: scale(1.15); }
        .nav-label { font-family: "Oswald"; font-size: 0.6rem; letter-spacing: 1.2px; font-weight: 500; }

        #guide-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; text-align: center; opacity: 1.0; z-index: 50; transition: opacity 0.5s; display: flex; flex-direction: column; gap: 15px; align-items: center; width: 100%; }
        #guide-overlay.hidden { opacity: 0; pointer-events: none; }
        .btn-guide-action { background: linear-gradient(135deg, rgba(0, 170, 255, 0.25), rgba(0, 140, 220, 0.2)); border: 1px solid rgba(0, 170, 255, 0.6); color: #fff; font-family: "Oswald"; font-size: 1rem; padding: 14px 24px; cursor: pointer; letter-spacing: 1.2px; border-radius: 8px; transition: all 0.3s ease; box-shadow: 0 4px 20px rgba(0, 170, 255, 0.3), 0 0 30px rgba(0, 170, 255, 0.2); pointer-events: auto; width: 280px; display: block; position: relative; backdrop-filter: blur(10px); }
        .btn-guide-action:hover { background: linear-gradient(135deg, rgba(0, 170, 255, 0.4), rgba(0, 140, 220, 0.35)); transform: scale(1.05) translateY(-2px); box-shadow: 0 6px 25px rgba(0, 170, 255, 0.5), 0 0 40px rgba(0, 170, 255, 0.3); border-color: #00aaff; }
        .btn-guide-action input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

        #menu-container { position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 60px); background: rgba(0,0,0,0.7); z-index: 800; display: none; justify-content: center; align-items: center; backdrop-filter: blur(8px); pointer-events: auto; }
        #menu-container.visible { display: flex; }
        #menu-box { width: 90%; max-width: 450px; height: 85%; max-height: 600px; background: linear-gradient(135deg, rgba(18, 22, 28, 0.98), rgba(15, 18, 24, 0.96)); border: 1px solid rgba(0, 170, 255, 0.2); border-radius: 12px; padding: 0; display: flex; flex-direction: column; box-shadow: 0 10px 50px rgba(0,0,0,0.9), 0 0 30px rgba(0, 170, 255, 0.1); overflow: hidden; backdrop-filter: blur(20px); }
        .scroll-content { padding: 20px; overflow-y: auto; flex: 1; display: none; flex-direction: column; }
        .scroll-content::-webkit-scrollbar { width: 6px; }
        .scroll-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 3px; }
        .scroll-content::-webkit-scrollbar-thumb { background: rgba(0, 170, 255, 0.3); border-radius: 3px; }
        .scroll-content::-webkit-scrollbar-thumb:hover { background: rgba(0, 170, 255, 0.5); }
        .scroll-content.active-view { display: flex; }

        .section-title { text-align:center; font-family:'Oswald'; margin-bottom:18px; color:#fff; font-size:1.15rem; letter-spacing:1.5px; border-bottom: 2px solid rgba(51, 51, 51, 0.5); padding-bottom: 12px; text-shadow: 0 2px 8px rgba(0,0,0,0.5); }
        .section-title.accent { color: #00aaff; border-color: rgba(0, 170, 255, 0.3); text-shadow: 0 0 10px rgba(0, 170, 255, 0.4); }
        .c-row { margin-bottom: 15px; flex-shrink: 0; }
        .c-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        .c-label { font-family: "Oswald"; letter-spacing: 1.2px; color:#999; text-transform: uppercase; font-size: 0.85rem; }
        .c-val { font-weight: bold; font-family: "Oswald"; font-size: 1.05rem; color: #fff; text-shadow: 0 1px 4px rgba(0,0,0,0.5); }
        .c-input-group { display: flex; align-items: center; gap: 8px; }
        input[type=range] { flex: 1; cursor: pointer; accent-color: #00aaff; height: 5px; margin: 0; background: linear-gradient(to right, #2a2a2a, #333); width: 100%; border-radius: 3px; }
        .btn { background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04)); border: 1px solid rgba(68, 68, 68, 0.8); color: #ddd; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.25s ease; font-family: "Oswald"; user-select: none; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.4); border-color: #555; }
        .btn:active { transform: translateY(0px); background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.08)); }
        .btn.active { background: linear-gradient(135deg, rgba(0, 170, 255, 0.35), rgba(0, 140, 220, 0.25)); border-color: #00aaff; color: #fff; box-shadow: 0 0 15px rgba(0, 170, 255, 0.4), 0 2px 8px rgba(0,0,0,0.3); }
        .btn-sm { width: 34px; height: 34px; font-size: 1.2rem; line-height: 1; color: #00aaff; flex-shrink: 0; font-weight: bold; }
        .func-row { display: flex; justify-content: space-between; margin-bottom: 20px; gap: 10px; flex-shrink: 0; }
        
        .preset-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
        .btn-preset { padding: 14px 16px; background: linear-gradient(135deg, rgba(0, 60, 100, 0.35), rgba(0, 50, 85, 0.25)); border-color: rgba(0, 68, 102, 0.6); flex-direction: column; align-items: flex-start; justify-content: center; text-align: left; width: 100%; transition: all 0.3s ease; }
        .btn-preset:hover { background: linear-gradient(135deg, rgba(0, 80, 130, 0.45), rgba(0, 70, 110, 0.35)); transform: translateX(4px); box-shadow: 0 4px 15px rgba(0, 170, 255, 0.2); border-color: rgba(0, 170, 255, 0.5); }
        .p-name { font-weight: bold; font-size: 0.95rem; margin-bottom: 2px; display: block; color: #eee; }
        .p-meta { font-size: 0.75rem; color: #aaa; display: block; }
        .p-warn { color: #ffeb3b; font-size: 0.7rem; display: block; margin-top: 2px; }
        .filter-container { background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(10,10,15,0.3)); padding: 12px; border-radius: 6px; border: 1px solid rgba(51, 51, 51, 0.6); margin-bottom: 15px; backdrop-filter: blur(5px); }
        .filter-row { display: flex; gap: 10px; align-items: center; margin-bottom: 8px; }
        .f-input { background: linear-gradient(135deg, #0f0f0f, #151515); border: 1px solid rgba(68, 68, 68, 0.8); color: #fff; padding: 9px 12px; border-radius: 6px; width: 100%; font-family: "Noto Sans JP"; font-size: 0.9rem; transition: all 0.3s ease; }
        .f-input:focus { outline: none; border-color: #00aaff; box-shadow: 0 0 10px rgba(0, 170, 255, 0.3); background: #1a1a1a; }
        .f-select { background: linear-gradient(135deg, #0f0f0f, #151515); border: 1px solid rgba(68, 68, 68, 0.8); color: #fff; padding: 9px 12px; border-radius: 6px; width: 100%; font-family: "Oswald"; font-size: 0.9rem; appearance: none; cursor: pointer; transition: all 0.3s ease; }
        .f-select:focus { outline: none; border-color: #00aaff; box-shadow: 0 0 10px rgba(0, 170, 255, 0.3); }
        .f-label { font-family: "Oswald"; font-size: 0.8rem; color: #999; white-space: nowrap; width: 70px; flex-shrink: 0; letter-spacing: 0.5px; }
        .real-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;}
        .real-item { padding: 13px 14px; background: linear-gradient(135deg, rgba(30, 30, 30, 0.6), rgba(25, 25, 28, 0.5)); border: 1px solid rgba(68, 68, 68, 0.6); border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: space-between; align-items: center; }
        .real-item:hover { background: linear-gradient(135deg, rgba(40, 45, 50, 0.7), rgba(35, 38, 42, 0.6)); border-color: rgba(0, 170, 255, 0.4); transform: translateX(3px); box-shadow: 0 3px 12px rgba(0, 170, 255, 0.15); }
        .real-info { flex: 1; }
        .real-place { font-weight: bold; font-size: 0.96rem; color: #fff; margin-bottom: 4px; letter-spacing: 0.3px; }
        .real-time { font-size: 0.75rem; color: #aaa; font-family: "Roboto Mono"; }
        .real-mag { font-family: "Oswald"; font-size: 1.15rem; color: #ffeb3b; margin-left: 10px; text-align: right; min-width: 50px; font-weight: 600; text-shadow: 0 1px 4px rgba(255, 235, 59, 0.3); }
        .real-max-int { font-family: "Oswald"; font-size: 1.1rem; color: #fff; background: linear-gradient(135deg, #3a3a3a, #2a2a2a); padding: 3px 8px; border-radius: 4px; margin-left: 10px; min-width: 32px; text-align: center; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
        
        #compass-area { display: flex; justify-content: center; margin: 12px 0; padding: 12px; background: linear-gradient(135deg, rgba(0,0,0,0.3), rgba(10,10,15,0.2)); border-radius: 6px; border: 1px solid rgba(51, 51, 51, 0.3); }
        #compass-ring { position: relative; width: 85px; height: 85px; border-radius: 50%; background: radial-gradient(circle, #2a2a2a 0%, #0f0f0f 100%); border: 3px solid #555; cursor: grab; touch-action: none; box-shadow: inset 0 0 15px rgba(0,0,0,0.8), 0 4px 12px rgba(0,0,0,0.5); }
        #compass-needle { position: absolute; top: 50%; left: 50%; width: 4px; height: 65px; background: linear-gradient(to bottom, #ff5555 50%, #ffffff 50%); transform-origin: center center; transform: translate(-50%, -50%) rotate(0deg); pointer-events: none; border-radius: 2px; box-shadow: 0 0 8px rgba(0,0,0,0.9), 0 0 4px rgba(255, 68, 68, 0.5); }
        .compass-mark { position: absolute; top: 3px; left: 50%; transform: translateX(-50%); font-family: "Oswald"; font-size: 0.75rem; color: #00aaff; font-weight: bold; pointer-events: none; text-shadow: 0 0 6px rgba(0, 170, 255, 0.6); }
        .btn-file-load { width: 100%; margin-top: 8px; padding: 11px 0; background: linear-gradient(135deg, rgba(0, 170, 255, 0.2), rgba(0, 140, 220, 0.15)); border: 1px solid rgba(0, 85, 136, 0.8); font-size: 0.8rem; color: #00ccff; letter-spacing: 1.2px; flex-shrink:0; display:flex; align-items:center; justify-content:center; cursor:pointer; border-radius: 6px; transition: all 0.3s ease; font-family: "Oswald"; }
        .btn-file-load:hover { background: linear-gradient(135deg, rgba(0, 170, 255, 0.3), rgba(0, 140, 220, 0.25)); border-color: #00aaff; box-shadow: 0 0 12px rgba(0, 170, 255, 0.3); }
        .btn-load-more { width: 100%; padding: 13px 0; background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04)); border: 1px solid rgba(68, 68, 68, 0.8); font-size: 0.9rem; color: #aaa; cursor: pointer; font-family:"Oswald"; letter-spacing:1.2px; margin-top: 10px; border-radius: 6px; transition: all 0.3s ease; }
        .btn-load-more:hover { background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.08)); border-color: #555; color: #ccc; box-shadow: 0 3px 10px rgba(0,0,0,0.3); }

        /* --- HISTORY MODE STYLES --- */
        .mode-toggle-container { display: flex; background: rgba(0,0,0,0.4); border-radius: 8px; padding: 4px; margin-bottom: 15px; border: 1px solid rgba(68, 68, 68, 0.6); }
        .mode-toggle-btn { flex: 1; padding: 8px; border: none; background: none; color: #888; font-family: "Oswald"; font-size: 0.8rem; cursor: pointer; border-radius: 6px; transition: all 0.3s; }
        .mode-toggle-btn.active { background: rgba(0, 170, 255, 0.3); color: #fff; box-shadow: 0 0 10px rgba(0, 170, 255, 0.2); }
        .history-load-row { display: flex; gap: 8px; margin-bottom: 15px; }
        .btn-history-load { flex: 1; padding: 11px 0; background: linear-gradient(135deg, rgba(0, 255, 128, 0.15), rgba(0, 200, 100, 0.1)); border: 1px solid rgba(0, 255, 128, 0.4); color: #00ff80; font-family: "Oswald"; font-size: 0.8rem; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.3s; }
        .btn-history-load:hover { background: rgba(0, 255, 128, 0.25); border-color: #00ff80; }

        #zoom-controls { position: absolute; bottom: 85px; right: 15px; display: flex; flex-direction: column; gap: 10px; z-index: 100; pointer-events: auto; }
        .btn-circle { width: 50px; height: 50px; font-size: 1.4rem; background: linear-gradient(135deg, rgba(15, 18, 22, 0.95), rgba(8, 10, 14, 0.9)); border: 1px solid rgba(68, 68, 68, 0.8); color: #fff; font-family: "Oswald"; cursor: pointer; border-radius: 50%; box-shadow: 0 4px 14px rgba(0,0,0,0.6), 0 0 20px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; backdrop-filter: blur(10px); }
        .btn-circle:hover { transform: scale(1.08); box-shadow: 0 6px 18px rgba(0,0,0,0.7), 0 0 25px rgba(255,255,255,0.1); border-color: #555; }
        .btn-circle:active { transform: scale(0.98); background: linear-gradient(135deg, rgba(20, 23, 28, 0.95), rgba(15, 18, 22, 0.9)); }
        .btn-circle.muted-active { color: #f44336; border-color: #ef5350; box-shadow: 0 0 15px rgba(244, 67, 54, 0.4), 0 4px 14px rgba(0,0,0,0.6); }
        .btn-circle.hidden-active { color: #aaa; border-color: #666; background: rgba(30,30,30,0.9); }
        .btn-reset-q { color: #ff5252; border-color: rgba(211, 47, 47, 0.8); margin-bottom: 5px; }
        .btn-reset-q:hover { box-shadow: 0 0 15px rgba(255, 82, 82, 0.4), 0 6px 18px rgba(0,0,0,0.7); border-color: #ff5252; } 
        
        #stat-panel { position: absolute; bottom: 125px; left: 15px; width: 125px; background: linear-gradient(135deg, rgba(10, 12, 16, 0.92), rgba(5, 7, 10, 0.88)); border: 1px solid rgba(51, 51, 51, 0.6); border-radius: 6px; padding: 10px; z-index: 95; display: none !important; font-family: "Oswald"; pointer-events: none; backdrop-filter: blur(12px); box-shadow: 0 4px 16px rgba(0,0,0,0.6); }
        .stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; font-size: 0.75rem; border-bottom:1px solid rgba(34, 34, 34, 0.5); padding-bottom:2px; }
        .stat-badge { width: 20px; text-align: center; border-radius: 3px; color: #fff; font-weight: bold; margin-right: 6px; font-size: 0.75rem; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
        .stat-count { font-weight: bold; color: #eee; }
        
        #legend-bar { 
            position: absolute; bottom: 65px; left: 10px; right: 10px; width: calc(100% - 20px); height: 28px; 
            display: flex; z-index: 90; border-radius: 4px; overflow: hidden;
            background: rgba(10, 12, 16, 0.6); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1); pointer-events: none; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); 
        }
        .l-item { 
            flex: 1; display: flex; justify-content: center; align-items: center; 
            font-family: "Oswald"; font-weight: 700; font-size: 0.85rem; color: #fff; 
            text-shadow: 0 1px 3px rgba(0,0,0,0.8); letter-spacing: 0.5px;
            position: relative;
        }
        .l-item::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.1), transparent 50%, rgba(0,0,0,0.2));
            pointer-events: none;
        }
        
        .report-section { background: linear-gradient(135deg, rgba(18, 22, 28, 0.6), rgba(15, 18, 24, 0.5)); margin-bottom: 12px; border-radius: 6px; overflow: hidden; border: 1px solid rgba(51, 51, 51, 0.6); box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .report-header { display: flex; align-items: center; padding: 10px 14px; background: linear-gradient(135deg, #252525, #1f1f1f); border-bottom: 1px solid rgba(68, 68, 68, 0.6); }
        .r-int-icon { width: 38px; height: 38px; display: flex; align-items: center; justify-content: center; font-weight: 900; font-family: "Oswald"; font-size: 1.25rem; border-radius: 5px; margin-right: 12px; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.6); box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
        .r-title { font-weight: bold; color: #eee; font-size: 1.02rem; letter-spacing: 0.3px; }
        .pref-block { padding: 10px 14px; border-bottom: 1px solid rgba(51, 51, 51, 0.5); display: flex; flex-direction: column; }
        .pref-name { font-size: 0.87rem; color: #aaa; margin-bottom: 5px; font-weight: bold; border-left: 3px solid rgba(0, 170, 255, 0.4); padding-left: 8px; letter-spacing: 0.3px; }
        .st-list { display: flex; flex-wrap: wrap; gap: 5px; }
        .st-tag { font-size: 0.75rem; background: linear-gradient(135deg, #353535, #2d2d2d); padding: 3px 7px; border-radius: 4px; border: 1px solid rgba(68, 68, 68, 0.6); color: #ccc; display: flex; align-items: center; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .st-val { margin-left: 6px; font-weight: bold; color: #fff; font-family: "Oswald"; text-shadow: 0 1px 2px rgba(0,0,0,0.4); }
        .report-info-box { background: linear-gradient(135deg, #252525, #1f1f1f); padding: 14px; border-radius: 6px; border: 1px solid rgba(68, 68, 68, 0.6); margin-bottom: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.85rem; color: #ccc; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .ri-label { color: #999; font-size: 0.72rem; letter-spacing: 0.3px; }
        .ri-val { color: #fff; font-weight: bold; font-family: "Oswald"; font-size: 1.02rem; text-shadow: 0 1px 3px rgba(0,0,0,0.4); }

        .bg-7 { background: #7c1a8c; }
        .bg-6p { background: #7f0d0d; }
        .bg-6m { background: #8c1a1a; }
        .bg-5p { background: #a50021; }
        .bg-5m { background: #d61a6c; }
        .bg-4 { background: #f04f26; }
        .bg-3 { background: #f09d26; }
        .bg-2 { background: #e6d836; color: #000; }
        .bg-1 { background: #46bc9c; color: #000; }

        #esim-control {
            position: absolute; top: 50px; left: 15px; pointer-events: auto; z-index: 150;
            display: none; flex-direction: column; gap: 10px; align-items: flex-start;
        }
        .btn-esim {
            background: linear-gradient(135deg, rgba(10, 12, 16, 0.92), rgba(5, 8, 12, 0.88)); 
            border: 1px solid rgba(68, 68, 68, 0.8); color: #aaa;
            font-family: "Oswald"; font-size: 0.82rem; padding: 8px 14px; border-radius: 6px;
            cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;
            width: fit-content; backdrop-filter: blur(10px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.5);
            letter-spacing: 0.5px;
        }
        .btn-esim svg { width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round; }
        .btn-esim.active {
            background: linear-gradient(135deg, rgba(255, 235, 59, 0.2), rgba(255, 200, 0, 0.15)); 
            border-color: rgba(255, 235, 59, 0.8); color: #ffeb3b;
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.3), 0 3px 10px rgba(0,0,0,0.5);
            text-shadow: 0 0 8px rgba(255, 235, 59, 0.4);
        }
        .btn-esim:hover { transform: scale(1.05) translateY(-1px); color: #fff; border-color: #888; box-shadow: 0 4px 14px rgba(0,0,0,0.6); }
        .btn-esim.active:hover { border-color: #ffeb3b; color: #ffeb3b; box-shadow: 0 0 20px rgba(255, 235, 59, 0.4), 0 4px 14px rgba(0,0,0,0.6); }

        /* アイコン表示切り替えボタン */
        #btn-toggle-region-icons {
            display: none; /* 初期は非表示 */
            background: rgba(0, 170, 255, 0.2);
            border-color: #00aaff;
            color: #00aaff;
            margin-bottom: 5px;
        }
        #btn-toggle-region-icons.inactive {
            background: rgba(0, 0, 0, 0.6);
            border-color: #444;
            color: #888;
        }

        /* 地域震度ポップアップ */
        #region-popup {
            position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%);
            background: rgba(10, 12, 16, 0.95); border: 1px solid #00aaff; border-radius: 8px;
            padding: 10px 18px; display: none; flex-direction: column; align-items: center;
            backdrop-filter: blur(12px); z-index: 2000; box-shadow: 0 8px 32px rgba(0,0,0,0.8);
            pointer-events: auto; min-width: 180px;
        }
        .popup-name { font-family: "Noto Sans JP"; font-weight: 900; font-size: 1.1rem; color: #fff; margin-bottom: 4px; }
        .popup-int { font-family: "Oswald"; font-weight: 700; font-size: 1.5rem; display: flex; align-items: center; gap: 8px; }
        .popup-int-val { padding: 2px 10px; border-radius: 4px; color: #fff; }

        /* --- NEW: ログモニター用スタイル (Resize & Filter) --- */
        #log-overlay {
            position: absolute; top: 100px; left: 50px; width: 400px; height: 250px;
            background: 
                linear-gradient(135deg, rgba(8, 8, 12, 0.96), rgba(12, 12, 18, 0.94)),
                linear-gradient(135deg, rgba(0, 200, 255, 0.6), rgba(0, 150, 200, 0.3), rgba(100, 50, 150, 0.2));
            background-clip: padding-box, border-box;
            background-origin: padding-box, border-box;
            border: 2px solid transparent;
            border-radius: 16px;
            overflow: hidden;
            z-index: 999; display: none; flex-direction: column; pointer-events: auto;
            backdrop-filter: blur(16px);
            box-shadow: 
                inset 0 0 20px rgba(0, 200, 255, 0.1),
                0 0 30px rgba(0, 200, 255, 0.2),
                0 0 60px rgba(100, 50, 150, 0.15),
                0 8px 32px rgba(0, 0, 0, 0.8);
            font-family: "Roboto Mono", monospace; font-size: 0.7rem; color: #ccc;
            min-width: 280px; min-height: 140px; max-width: 90vw; max-height: 90vh;
            transition: box-shadow 0.3s ease;
        }
        #log-overlay:hover {
            box-shadow: 
                inset 0 0 20px rgba(0, 200, 255, 0.15),
                0 0 40px rgba(0, 200, 255, 0.3),
                0 0 80px rgba(100, 50, 150, 0.25),
                0 8px 32px rgba(0, 0, 0, 0.9);
        }
        /* リサイズハンドル - 8方向対応 */
        .log-resize-handle {
            position: absolute; background: transparent;
            border: none;
            pointer-events: auto; z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #log-overlay:hover .log-resize-handle {
            opacity: 1;
        }
        
        /* 上下左右のハンドル */
        #log-resize-handle-top {
            top: 0; left: 0; right: 0; height: 4px; cursor: ns-resize;
            background: linear-gradient(to bottom, rgba(0, 200, 255, 0.4), transparent);
        }
        #log-resize-handle-bottom {
            bottom: 0; left: 0; right: 0; height: 4px; cursor: ns-resize;
            background: linear-gradient(to top, rgba(0, 200, 255, 0.4), transparent);
        }
        #log-resize-handle-left {
            top: 0; left: 0; bottom: 0; width: 4px; cursor: ew-resize;
            background: linear-gradient(to right, rgba(0, 200, 255, 0.4), transparent);
        }
        #log-resize-handle-right {
            top: 0; right: 0; bottom: 0; width: 4px; cursor: ew-resize;
            background: linear-gradient(to left, rgba(0, 200, 255, 0.4), transparent);
        }
        
        /* 四隅のハンドル */
        #log-resize-handle-top-left {
            top: 0; left: 0; width: 20px; height: 20px; cursor: nwse-resize;
            background: linear-gradient(135deg, rgba(0, 200, 255, 0.5) 0%, rgba(0, 200, 255, 0.2) 50%, transparent 100%);
            border-top: 2px solid rgba(0, 200, 255, 0.6);
            border-left: 2px solid rgba(0, 200, 255, 0.6);
            border-radius: 16px 0 0 0;
        }
        #log-resize-handle-top-right {
            top: 0; right: 0; width: 20px; height: 20px; cursor: nesw-resize;
            background: linear-gradient(225deg, rgba(0, 200, 255, 0.5) 0%, rgba(0, 200, 255, 0.2) 50%, transparent 100%);
            border-top: 2px solid rgba(0, 200, 255, 0.6);
            border-right: 2px solid rgba(0, 200, 255, 0.6);
            border-radius: 0 16px 0 0;
        }
        #log-resize-handle-bottom-left {
            bottom: 0; left: 0; width: 20px; height: 20px; cursor: nesw-resize;
            background: linear-gradient(45deg, rgba(0, 200, 255, 0.5) 0%, rgba(0, 200, 255, 0.2) 50%, transparent 100%);
            border-bottom: 2px solid rgba(0, 200, 255, 0.6);
            border-left: 2px solid rgba(0, 200, 255, 0.6);
            border-radius: 0 0 0 16px;
        }
        #log-resize-handle-bottom-right {
            bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize;
            background: linear-gradient(315deg, rgba(0, 200, 255, 0.5) 0%, rgba(0, 200, 255, 0.2) 50%, transparent 100%);
            border-bottom: 2px solid rgba(0, 200, 255, 0.6);
            border-right: 2px solid rgba(0, 200, 255, 0.6);
            border-radius: 0 0 16px 0;
        }
        #log-header {
            background: linear-gradient(180deg, rgba(20, 25, 35, 0.98), rgba(15, 18, 28, 0.95));
            padding: 6px 8px; border-bottom: 1px solid transparent;
            border-image: linear-gradient(90deg, rgba(0, 200, 255, 0.4), rgba(0, 200, 255, 0.1)) 1;
            display: flex; justify-content: flex-start; align-items: flex-start; flex-shrink: 0;
            cursor: grab; user-select: none; transition: all 0.2s;
            position: relative;
            gap: 6px;
            flex-wrap: wrap;
            min-height: auto;
            border-radius: 14px 14px 0 0;
        }
        #log-header:hover {
            background: linear-gradient(180deg, rgba(25, 30, 40, 0.98), rgba(20, 23, 33, 0.96));
            box-shadow: inset 0 1px 8px rgba(0, 200, 255, 0.1);
        }
        #log-header:active { 
            cursor: grabbing; 
            background: linear-gradient(180deg, rgba(30, 35, 45, 0.99), rgba(25, 28, 38, 0.97));
        }
        #log-header::before {
            content: ''; display: inline-block; width: 14px; height: 2px;
            background: linear-gradient(90deg, rgba(0, 200, 255, 0.6), rgba(0, 200, 255, 0.2));
            border-radius: 1px; flex-shrink: 0; margin-top: 3px;
            box-shadow: 0 0 6px rgba(0, 200, 255, 0.4);
        }
        #log-header::after {
            content: 'LOG';
            font-size: 0.5rem; color: rgba(0, 200, 255, 0.5);
            font-family: 'Oswald', sans-serif;
            letter-spacing: 1px;
            font-weight: 600;
            text-shadow: 0 0 6px rgba(0, 200, 255, 0.2);
            pointer-events: none;
            white-space: nowrap;
            flex-shrink: 0;
            margin-top: 2px;
        }
        #log-header .log-filters {
            flex-shrink: 0;
            display: flex;
            gap: 3px;
        }
        #log-header > div:last-child {
            display: flex;
            gap: 3px;
            flex-shrink: 0;
        }
        .log-filters { display: flex; gap: 3px; flex-wrap: nowrap; align-items: center; }
        .log-filter-btn {
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.8), rgba(25, 25, 35, 0.7));
            border: 1px solid rgba(100, 100, 120, 0.5); color: #777; font-size: 0.5rem;
            padding: 2px 5px; border-radius: 2px; cursor: pointer; transition: all 0.2s;
            font-family: "Oswald"; letter-spacing: 0.2px; font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
            white-space: nowrap;
            min-width: 28px;
            text-align: center;
        }
        .log-filter-btn:hover {
            border-color: rgba(150, 150, 170, 0.6);
            background: linear-gradient(135deg, rgba(40, 40, 50, 0.9), rgba(35, 35, 45, 0.8));
        }
        .log-filter-btn.active { 
            border-color: currentColor; 
            background: linear-gradient(135deg, rgba(50, 50, 70, 0.9), rgba(40, 40, 60, 0.8));
            box-shadow: 0 0 12px rgba(0, 200, 255, 0.3), 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        .log-filter-btn.f-SYS.active { color: #aaa; text-shadow: 0 0 4px rgba(170, 170, 170, 0.5); }
        .log-filter-btn.f-NET.active { color: #00ff80; text-shadow: 0 0 4px rgba(0, 255, 128, 0.5); }
        .log-filter-btn.f-SIM.active { color: #ffeb3b; text-shadow: 0 0 4px rgba(255, 235, 59, 0.5); }
        .log-filter-btn.f-PERF.active { color: #ff5252; text-shadow: 0 0 4px rgba(255, 82, 82, 0.5); }

        #log-content {
            flex: 1; overflow-y: auto; padding: 8px 10px; display: flex; flex-direction: column; gap: 2px;
            background: linear-gradient(to bottom, rgba(8, 8, 12, 0.5), rgba(8, 8, 12, 0.3));
            border-radius: 0 0 14px 14px;
        }
        #log-content::-webkit-scrollbar { width: 6px; }
        #log-content::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
        #log-content::-webkit-scrollbar-thumb { background: linear-gradient(to bottom, rgba(0, 200, 255, 0.4), rgba(0, 150, 200, 0.2)); border-radius: 3px; }
        #log-content::-webkit-scrollbar-thumb:hover { background: linear-gradient(to bottom, rgba(0, 200, 255, 0.6), rgba(0, 150, 200, 0.4)); }
        
        .log-entry { 
            display: flex; gap: 8px; line-height: 1.4; 
            border-bottom: 1px solid rgba(0, 200, 255, 0.08);
            padding: 2px 0;
            transition: background 0.2s;
        }
        .log-entry:hover {
            background: rgba(0, 200, 255, 0.05);
        }
        .log-time { color: #555; min-width: 60px; font-size: 0.65rem; }
        .log-cat { font-weight: bold; min-width: 45px; text-align: center; font-size: 0.65rem; }
        .cat-SYS { color: #999; text-shadow: 0 0 4px rgba(153, 153, 153, 0.3); }
        .cat-NET { color: #00ff80; text-shadow: 0 0 4px rgba(0, 255, 128, 0.4); }
        .cat-SIM { color: #ffeb3b; text-shadow: 0 0 4px rgba(255, 235, 59, 0.4); }
        .cat-PERF { color: #ff5252; text-shadow: 0 0 4px rgba(255, 82, 82, 0.4); }
        .log-msg { color: #ddd; white-space: pre-wrap; word-break: break-all; font-size: 0.68rem; }
        
        /* フィルタリング時の表示制御 (bodyクラスで制御) */
        body.hide-log-SYS .log-entry[data-cat="SYS"] { display: none; }
        body.hide-log-NET .log-entry[data-cat="NET"] { display: none; }
        body.hide-log-SIM .log-entry[data-cat="SIM"] { display: none; }
        body.hide-log-PERF .log-entry[data-cat="PERF"] { display: none; }

        .btn-log-action { 
            background: linear-gradient(135deg, rgba(40, 40, 50, 0.7), rgba(35, 35, 45, 0.6));
            border: 1px solid rgba(100, 100, 120, 0.5); color: #888; font-size: 0.5rem; 
            padding: 2px 6px; border-radius: 2px; cursor: pointer; transition: all 0.2s;
            font-family: "Oswald"; font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
            white-space: nowrap;
        }
        .btn-log-action:hover { 
            border-color: rgba(0, 200, 255, 0.6); 
            color: #0ff; 
            background: linear-gradient(135deg, rgba(50, 50, 70, 0.8), rgba(40, 40, 60, 0.7));
            box-shadow: 0 0 8px rgba(0, 200, 255, 0.4), 0 2px 4px rgba(0, 0, 0, 0.5);
            text-shadow: 0 0 4px rgba(0, 200, 255, 0.5);
        }
        .btn-log-action:active {
            background: linear-gradient(135deg, rgba(60, 60, 80, 0.9), rgba(50, 50, 70, 0.8));
            box-shadow: inset 0 0 8px rgba(0, 200, 255, 0.2), 0 2px 4px rgba(0, 0, 0, 0.5);
        }

    </style>
</head>
<body>
    <div id="loading" onclick="this.style.display='none'"><div class="loader"></div><div>INITIALIZING...</div></div>
    
    <div id="ui-layer">
        <div id="info-bar">
            <div id="clock">00:00:00</div>
            <div class="separator"></div>
            <div class="ib-item" style="min-width: 60px;">
                <span class="ib-label">HYPO</span>
                <span id="ib-region" class="ib-val">---</span>
            </div>
            <div class="separator"></div>
            <div class="ib-item">
                <span class="ib-label">DEP</span>
                <span id="ib-depth" class="ib-val">---</span>
            </div>
            <div class="separator"></div>
            <div class="ib-item">
                <span class="ib-label">MAG</span>
                <span id="ib-mag" class="ib-val warn">---</span>
            </div>
        </div>

        <div id="region-popup" class="interactive" onclick="this.style.display='none'">
            <div class="popup-name" id="pop-name">---</div>
            <div class="popup-int">
                <span style="font-size: 0.8rem; color: #888;">MAX INT:</span>
                <span class="popup-int-val" id="pop-int-val">---</span>
            </div>
        </div>
        
        <div id="log-overlay">
            <div id="log-resize-handle-top" class="log-resize-handle interactive"></div>
            <div id="log-resize-handle-bottom" class="log-resize-handle interactive"></div>
            <div id="log-resize-handle-left" class="log-resize-handle interactive"></div>
            <div id="log-resize-handle-right" class="log-resize-handle interactive"></div>
            <div id="log-resize-handle-top-left" class="log-resize-handle interactive"></div>
            <div id="log-resize-handle-top-right" class="log-resize-handle interactive"></div>
            <div id="log-resize-handle-bottom-left" class="log-resize-handle interactive"></div>
            <div id="log-resize-handle-bottom-right" class="log-resize-handle interactive"></div>
            <div id="log-header" class="interactive">
                <div class="log-filters" style="pointer-events: auto;">
                    <button class="log-filter-btn f-SYS active interactive" onclick="sysLogger.toggleFilter('SYS')">SYS</button>
                    <button class="log-filter-btn f-NET active interactive" onclick="sysLogger.toggleFilter('NET')">NET</button>
                    <button class="log-filter-btn f-SIM active interactive" onclick="sysLogger.toggleFilter('SIM')">SIM</button>
                    <button class="log-filter-btn f-PERF active interactive" onclick="sysLogger.toggleFilter('PERF')">PERF</button>
                </div>
                <div style="display:flex; gap:5px; pointer-events: auto;">
                    <button class="btn-log-action interactive" onclick="sysLogger.clear()">CLEAR</button>
                    <button class="btn-log-action interactive" onclick="toggleLogMonitor()">CLOSE</button>
                </div>
            </div>
            <div id="log-content">
                <div style="color:#666; text-align:center; padding:20px;">-- NO LOGS --</div>
            </div>
        </div>

        <div id="esim-control">
            <button class="btn-esim interactive" id="btn-toggle-esim" onclick="toggleESIM()">
                <svg viewBox="0 0 24 24"><path d="M3 3v18h18M7 16l4-4 4 4 5-8"></path></svg>
                <span>推計震度分布</span>
            </button>
            <button class="btn-esim interactive active" id="btn-toggle-st" onclick="toggleStations()">
                <svg viewBox="0 0 24 24"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                <span>観測点</span>
            </button>
            <button class="btn-esim interactive" id="btn-toggle-avs" onclick="toggleAVSView()">
                <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg>
                <span>地盤(AVS30)</span>
            </button>
            <button class="btn-esim interactive active" id="btn-toggle-plum" onclick="togglePLUM()">
                <svg viewBox="0 0 24 24"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0zM12 9v4M12 17h.01"></path></svg>
                <span>緊急地震速報マップ</span>
            </button>
        </div>
        <div id="guide-overlay">
            <style>
                .btn-guide-action svg { width: 18px; height: 18px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; vertical-align: middle; margin-right: 10px; }
            </style>
            <label id="btn-load-map" class="btn-guide-action interactive">
                <svg viewBox="0 0 24 24"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>
                LOAD MAP (GeoJSON)
                <input type="file" accept=".json,.geojson,.txt" onclick="this.value=null" onchange="loadMapFile(this)">
            </label>
            <label id="btn-load-station" class="btn-guide-action interactive">
                <svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
                LOAD STATION DATA
                <input type="file" accept=".csv,.json,.txt" onclick="this.value=null" onchange="loadStationFile(this)">
            </label>
            <label id="btn-load-epicenter" class="btn-guide-action interactive" style="border-color:#e6d836; color:#e6d836; background:rgba(230, 216, 54, 0.15);">
                <svg viewBox="0 0 24 24"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                LOAD EPICENTER DATA
                <input type="file" accept=".json,.geojson,.txt" onclick="this.value=null" onchange="loadEpicenterFile(this)">
            </label>
            <div style="font-size:0.75rem; color:#888; margin-top:5px;">Supports: stations_with_amp.json, japan.geojson, 震央地名.geojson</div>
        </div>

        <div id="menu-container">
            <div id="menu-box">
                <div id="view-real" class="scroll-content">
                    <div class="section-title accent">JMA EARTHQUAKE DATA</div>
                    
                    <div class="mode-toggle-container interactive">
                        <button id="btn-mode-api" class="mode-toggle-btn active" onclick="setRealDataSubMode('api')">APIモード</button>
                        <button id="btn-mode-history" class="mode-toggle-btn" onclick="setRealDataSubMode('history')">HISTORYモード</button>
                    </div>

                    <div id="api-controls">
                        <button class="btn btn-file-load interactive" style="margin-bottom:15px;" onclick="fetchRealData(false)">
                            <svg viewBox="0 0 24 24" style="width:16px; height:16px; margin-right:8px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round;"><path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                            REFRESH (LATEST)
                        </button>
                    </div>

                    <div id="history-controls" style="display:none;">
                        <div class="history-load-row">
                            <label id="btn-load-history-file" class="btn-history-load interactive">
                                <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:none; stroke:currentColor; stroke-width:2; stroke-linecap:round; stroke-linejoin:round;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>
                                JSONを読み込む
                                <input type="file" accept=".json" style="display:none;" onchange="loadHistoryFile(this)">
                            </label>
                        </div>
                    </div>
                    <div class="filter-container interactive">
                        <div class="filter-row"><span class="f-label">REGION:</span><input type="text" id="filter-region" class="f-input" placeholder="地名 (例: 石川)" oninput="filterRealData()"></div>
                        <div class="filter-row"><span class="f-label">MIN MAG:</span><input type="number" id="filter-mag" class="f-input" value="1.0" step="0.5" min="0" max="9" oninput="filterRealData()"></div>
                        <div class="filter-row"><span class="f-label">SORT BY:</span><select id="sort-type" class="f-select" onchange="filterRealData()"><option value="date">DATE (NEWEST)</option><option value="mag">MAGNITUDE (HIGH)</option><option value="int">SHINDO (MAX INT)</option></select></div>
                    </div>
                    <div id="real-data-list" class="real-list interactive"><div style="text-align:center; color:#666; padding:20px;">Tap REFRESH to load data</div></div>
                    <button id="btn-more" class="btn-load-more interactive" onclick="fetchRealData(true)" style="display:none;"><svg viewBox="0 0 24 24" style="width:14px; height:14px; margin-right:6px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round; vertical-align:middle;"><path d="M7 13l5 5 5-5M7 6l5 5 5-5"></path></svg>LOAD OLDER (+50)</button>
                </div>
                
                <div id="view-presets" class="scroll-content">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24" style="width:18px; height:18px; margin-right:8px; vertical-align:middle; fill:none; stroke:currentColor; stroke-width:2; stroke-linecap:round; stroke-linejoin:round;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                        ACTUAL: Historical Disasters
                    </div>
                    <div class="preset-grid interactive">
                        <button class="btn btn-preset" onclick="triggerPreset(37.50, 137.30, 7.6, 16, 50, 150, 0.1)"><span class="p-name">能登半島地震 (2024)</span><span class="p-meta">M7.6 / Depth 16km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(37.70, 141.60, 7.4, 57, 20, 50, 0.5)"><span class="p-name">福島県沖地震 (2022)</span><span class="p-meta">M7.4 / Depth 57km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(32.75, 130.76, 7.3, 12, 220, 40, 0.9)"><span class="p-name">熊本地震 本震 (2016)</span><span class="p-meta">M7.3 / Depth 12km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(38.10, 142.86, 9.0, 24, 195, 450, 0.5)"><span class="p-name">東日本大震災 (2011)</span><span class="p-meta">M9.0 / Depth 24km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(39.03, 140.88, 7.2, 8, 20, 30, 0.2)"><span class="p-name">岩手・宮城内陸地震 (2008)</span><span class="p-meta">M7.2 / Depth 8km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(37.29, 138.87, 6.8, 13, 210, 25, 0.5)"><span class="p-name">新潟県中越地震 (2004)</span><span class="p-meta">M6.8 / Depth 13km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(41.78, 144.08, 8.0, 45, 230, 100, 0.2)"><span class="p-name">十勝沖地震 (2003)</span><span class="p-meta">M8.0 / Depth 45km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(35.27, 133.35, 7.3, 11, 150, 30, 0.5)"><span class="p-name">鳥取県西部地震 (2000)</span><span class="p-meta">M7.3 / Depth 11km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(34.60, 135.04, 7.3, 16, 233, 40, 1.0)"><span class="p-name">阪神・淡路大震災 (1995)</span><span class="p-meta">M7.3 / Depth 16km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(36.10, 136.20, 7.1, 10, 340, 30, 0.5)"><span class="p-name">福井地震 (1948)</span><span class="p-meta">M7.1 / Depth 10km</span><span class="p-tag past">ACTUAL</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(35.33, 139.15, 7.9, 23, 110, 100, 0.5)"><span class="p-name">大正関東大震災 (1923)</span><span class="p-meta">M7.9 / Depth 23km</span><span class="p-tag past">ACTUAL</span></button>
                    </div>
                    <div style="height:25px;"></div>
                    <div class="section-title">
                        <svg viewBox="0 0 24 24" style="width:18px; height:18px; margin-right:8px; vertical-align:middle; fill:none; stroke:currentColor; stroke-width:2; stroke-linecap:round; stroke-linejoin:round;"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0zM12 9v4M12 17h.01"></path></svg>
                        SCENARIO: Future Risks
                    </div>
                    <div class="preset-grid interactive">
                        <button class="btn btn-preset" onclick="triggerPreset(33.00, 135.60, 9.1, 30, 245, 700, 0.5)"><span class="p-name">南海トラフ巨大地震</span><span class="p-meta">Scenario M9.1 / L=700km</span><span class="p-warn">MEGATHRUST</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(42.50, 145.00, 9.3, 20, 230, 600, 0.1)"><span class="p-name">千島海溝巨大地震</span><span class="p-meta">Scenario M9.3 / Hokkaido</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(35.65, 139.75, 7.3, 25, 135, 30, 0.5)"><span class="p-name">首都直下地震</span><span class="p-meta">Scenario M7.3 / Tokyo</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(34.90, 139.80, 8.2, 20, 135, 150, 0.5)"><span class="p-name">元禄型 関東地震</span><span class="p-meta">Scenario M8.2 / Kanto</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(43.00, 141.60, 7.6, 15, 340, 60, 0.8)"><span class="p-name">札幌直下地震</span><span class="p-meta">Scenario M7.6 / Sapporo</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(35.10, 136.65, 7.5, 12, 330, 50, 0.2)"><span class="p-name">名古屋直下地震</span><span class="p-meta">Scenario M7.5 / Nagoya</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(34.60, 135.50, 7.6, 15, 360, 40, 0.0)"><span class="p-name">上町断層帯地震</span><span class="p-meta">Scenario M7.6 / Osaka</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(35.20, 135.80, 7.5, 15, 20, 50, 0.2)"><span class="p-name">花折断層帯地震</span><span class="p-meta">Scenario M7.5 / Kyoto</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(36.23, 137.97, 7.7, 10, 160, 150, 0.5)"><span class="p-name">糸魚川-静岡構造線</span><span class="p-meta">Scenario M7.7 / Nagano</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(35.75, 139.35, 7.4, 14, 310, 30, 0.1)"><span class="p-name">立川断層帯地震</span><span class="p-meta">Scenario M7.4 / Tama</span><span class="p-tag future">FUTURE</span></button>
                        <button class="btn btn-preset" onclick="triggerPreset(31.60, 131.80, 8.0, 25, 210, 80, 1.0)"><span class="p-name">日向灘地震</span><span class="p-meta">Scenario M8.0 / Kyushu</span><span class="p-tag future">FUTURE</span></button>
                    </div>
                </div>

                <div id="view-settings" class="scroll-content">
                    <div class="section-title accent">MANUAL CONTROLS</div>
                    
                    <div class="c-row">
                        <div class="c-header"><span class="c-label">REGION INTENSITY MODE</span></div>
                        <div class="func-row" style="margin-bottom:0; gap:5px;">
                            <button id="btn-mode-region-on" class="btn" style="flex:1;" onclick="setRegionIntMode(true)">ON</button>
                            <button id="btn-mode-region-off" class="btn active" style="flex:1;" onclick="setRegionIntMode(false)">OFF</button>
                        </div>
                    </div>
                    <div class="c-row"><div class="c-header"><span class="c-label">DISPLAY MODE</span></div><div class="func-row" style="margin-bottom:0; gap:5px;"><button id="btn-mode-max" class="btn active" style="flex:1;" onclick="setDisplayMode('max')">MAX HOLD</button><button id="btn-mode-real" class="btn" style="flex:1;" onclick="setDisplayMode('real')">REAL-TIME</button></div></div>
                    
	                    <div class="c-row" style="margin-top:15px;">
	                        <div class="c-header"><span class="c-label">STATION SHAPE</span></div>
	                        <div class="func-row" style="margin-bottom:0; gap:5px;">
	                            <button id="btn-shape-circle" class="btn active" style="flex:1;" onclick="setStationShape(true)">● CIRCLE</button>
	                            <button id="btn-shape-rect" class="btn" style="flex:1;" onclick="setStationShape(false)">■ RECT (FAST)</button>
	                        </div>
	                    </div>
	                    <div class="c-row" style="margin-top:15px;">
	                        <div class="c-header"><span class="c-label">INTENSITY NUMBERS</span></div>
	                        <div class="func-row" style="margin-bottom:0; gap:5px;">
	                            <button id="btn-int-num-on" class="btn active" style="flex:1;" onclick="setIntNumberVisible(true)">ON</button>
	                            <button id="btn-int-num-off" class="btn" style="flex:1;" onclick="setIntNumberVisible(false)">OFF</button>
	                        </div>
	                    </div>

                    <div class="c-row" style="margin-top:15px;"><div class="c-header"><span class="c-label">RUPTURE START</span><span id="d-rup" class="c-val">0.0 (END)</span></div><div class="c-input-group interactive"><input type="range" id="rup-start" min="0.0" max="1.0" step="0.1" value="0.0" oninput="updateDisplay()"></div></div>
                    <div class="func-row" style="margin-top:20px;"><button class="btn btn-reset interactive" onclick="resetSim(); switchTab('sim')">RESET SIMULATION</button></div>
                    <div class="c-row"><div class="c-header"><span class="c-label">MAGNITUDE</span><span id="d-mag" class="c-val" style="color:#ff4444">7.6</span></div><div class="c-input-group interactive"><button class="btn btn-sm" onclick="adjustParam('mag', -0.1)">-</button><input type="range" id="mag" min="4.0" max="9.5" step="0.1" value="7.6" oninput="updateDisplay()"><button class="btn btn-sm" onclick="adjustParam('mag', 0.1)">+</button></div></div>
                    <div class="c-row"><div class="c-header"><span class="c-label">DEPTH</span><span id="d-dep" class="c-val" style="color:#00aaff">16km</span></div><div class="c-input-group interactive"><button class="btn btn-sm" onclick="adjustParam('depth', -10)">-</button><input type="range" id="depth" min="10" max="600" step="10" value="16" oninput="updateDisplay()"><button class="btn btn-sm" onclick="adjustParam('depth', 10)">+</button></div></div>
                    <div class="c-row"><div class="c-header"><span class="c-label">FAULT STRIKE</span><span id="d-str" class="c-val" style="color:#eee">0°</span></div><div id="compass-area" class="interactive"><div id="compass-ring"><div class="compass-mark">N</div><div id="compass-needle"></div></div></div></div>
                    <div class="c-row">
                        <div class="c-header"><span class="c-label">SIM SPEED</span><span id="d-spd" class="c-val">x10.0</span></div>
                        <div class="c-input-group interactive">
                            <button class="btn btn-sm" onclick="adjustSpeed(-0.5)">-</button>
                            <input type="range" id="speed" min="0.1" max="20" step="0.1" value="10" oninput="updateDisplay()">
                            <button class="btn btn-sm" onclick="adjustSpeed(0.5)">+</button>
                        </div>
                    </div>
                    
                    <div class="c-row" style="margin-top:20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top:15px; display:flex; gap:10px;">
                         <button class="btn interactive" onclick="toggleLogMonitor()" style="flex:1; color:#00ff80; border-color:rgba(0,255,128,0.5);">
                             <svg viewBox="0 0 24 24" style="width:16px; height:16px; margin-right:8px; fill:none; stroke:currentColor; stroke-width:2;"><path d="M4 17l6-6 4 4 6-6M4 21h16"></path></svg>
                             OPEN LOG MONITOR
                         </button>
                         <button class="btn interactive" onclick="showStructureManual()" style="flex:1; color:#00aaff; border-color:rgba(0,170,255,0.5);">
                             <svg viewBox="0 0 24 24" style="width:16px; height:16px; margin-right:8px; fill:none; stroke:currentColor; stroke-width:2;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                             VIEW STRUCTURE
                         </button>
                    </div>

                    <div style="margin-top:30px; padding-top:15px; border-top:1px solid rgba(255,255,255,0.05); text-align:center;">
                        <span style="font-family:'Oswald'; font-size:0.7rem; color:rgba(255,255,255,0.3); letter-spacing:1px;">
                            EQS SIMULATION SYSTEM <br>
                            <span style="color:rgba(0,170,255,0.5);">v34.4 Auto-Load & Fix</span>
                        </span>
                    </div>

                </div>
                
                <div id="view-structure" class="scroll-content">
                     <div class="section-title accent">STRUCTURE SPEC</div>
                     <div id="structure-content" style="white-space: pre-wrap; font-family: 'Roboto Mono'; font-size: 0.7rem; color: #ccc; text-align: left; user-select: text;"></div>
                     <button class="btn interactive" onclick="switchTab('settings')" style="margin-top:15px;">CLOSE</button>
                </div>

                <div id="view-report" class="scroll-content">
                    <div class="section-title accent">INTENSITY MONITOR</div>
                    <div id="report-content" class="interactive">
                        <div style="text-align:center; color:#666; padding:30px;">
                            <div>Waiting for Event...</div>
                            <div style="font-size:0.8rem; margin-top:10px;">Updates live during simulation.</div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <div id="stat-panel"></div>
        <div id="zoom-controls">
            <button class="btn-circle btn-reset-q interactive" onclick="resetSim()" title="Reset/Clear">
                <svg viewBox="0 0 24 24" style="width:20px; height:20px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round;"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
            <button id="btn-toggle-region-icons" class="btn-circle interactive" onclick="toggleRegionIcons()" title="Toggle Region Icons">
                <svg viewBox="0 0 24 24" style="width:20px; height:20px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round;"><rect x="3" y="3" width="18" height="18" rx="4" ry="4"></rect><path d="M9 9h6v6H9z"></path></svg>
            </button>
            <button id="q-mute" class="btn-circle interactive" onclick="toggleMute()" title="Toggle Sound">
                <svg id="svg-mute" viewBox="0 0 24 24" style="width:20px; height:20px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round;"><path d="M11 5L6 9H2v6h4l5 4V5zM19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
            </button>
            <div style="height:5px;"></div>
            <button class="btn-circle interactive" onclick="manualZoom(1.2)">
                <svg viewBox="0 0 24 24" style="width:20px; height:20px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round;"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </button>
            <button class="btn-circle interactive" onclick="manualZoom(0.8)">
                <svg viewBox="0 0 24 24" style="width:20px; height:20px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round;"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </button>
            <button id="btn-comparison" class="btn interactive" style="display:none; position:fixed; bottom:105px; right:70px; z-index:1100; padding:10px 15px; background:rgba(0,170,255,0.8); border:1px solid #00aaff; color:#fff; font-family:'Oswald'; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.5);" onclick="toggleComparisonMode()">
                SIMULATE THIS EVENT
            </button>
        </div>
        <div id="legend-bar"><div class="l-item" style="background:#333;">0</div><div class="l-item" style="background:#46bc9c;">1</div><div class="l-item" style="background:#e6d836;">2</div><div class="l-item" style="background:#f09d26;">3</div><div class="l-item" style="background:#f04f26;">4</div><div class="l-item" style="background:#d61a6c;">5-</div><div class="l-item" style="background:#a50021;">5+</div><div class="l-item" style="background:#8c1a1a;">6-</div><div class="l-item" style="background:#7f0d0d;">6+</div><div class="l-item" style="background:#7c1a8c;">7</div></div>
        
        <nav id="bottom-nav">
            <button class="nav-btn active interactive" id="btn-sim" onclick="switchTab('sim')">
                <span class="nav-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg></span>
                <span class="nav-label">SIMULATION</span>
            </button>
            <button class="nav-btn interactive" id="btn-real" onclick="switchTab('real')">
                <span class="nav-icon"><svg viewBox="0 0 24 24"><path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.59 16.11a6 6 0 0 1 6.82 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg></span>
                <span class="nav-label">REAL DATA</span>
            </button>
            <button class="nav-btn interactive" id="btn-presets" onclick="switchTab('presets')">
                <span class="nav-icon"><svg viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg></span>
                <span class="nav-label">PRESETS</span>
            </button>
            <button class="nav-btn interactive" id="btn-report" onclick="switchTab('report')">
                <span class="nav-icon"><svg viewBox="0 0 24 24"><path d="M18 20V10M12 20V4M6 20v-6"></path></svg></span>
                <span class="nav-label">MONITOR</span>
            </button>
            <button class="nav-btn interactive" id="btn-settings" onclick="switchTab('settings')">
                <span class="nav-icon"><svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"></path></svg></span>
                <span class="nav-label">SETTINGS</span>
            </button>
        </nav>
    </div>

    <canvas id="world"></canvas>
    <script>
        // ============================================================================
        // [DEVELOPER NOTE & MAINTENANCE RULE]
        // The "STRUCTURE_MANUAL_TEXT" constant at the bottom of this script contains
        // the full structural documentation of this application.
        // ============================================================================

        // --- NEW: Logger Class (with Filter & ERROR Support) ---
        const sysLogger = {
            logs: [],
            el: null,
            init: function() {
                this.el = document.getElementById('log-content');
                this.log('SYS', 'Logger initialized.');
            },
            log: function(cat, msg) {
                const now = new Date();
                const time = now.toLocaleTimeString('ja-JP', {hour12:false}) + '.' + now.getMilliseconds().toString().padStart(3, '0');
                const entry = {time, cat, msg};
                this.logs.push(entry);
                if(this.logs.length > 100) this.logs.shift(); 
                
                if(this.el) {
                    const isAtBottom = (this.el.scrollHeight - this.el.scrollTop - this.el.clientHeight) < 30;
                    const row = document.createElement('div');
                    row.className = 'log-entry';
                    row.setAttribute('data-cat', cat);
                    row.innerHTML = `<div class="log-time">${time}</div><div class="log-cat cat-${cat}">[${cat}]</div><div class="log-msg">${msg}</div>`;
                    this.el.appendChild(row);
                    if(isAtBottom) this.el.scrollTop = this.el.scrollHeight;
                }
            },
            error: function(code, msg, errObj) {
                const fullMsg = `[${code}] ${msg}`;
                this.log('ERR', fullMsg);
                if(errObj) console.error(fullMsg, errObj);
            },
            clear: function() {
                this.logs = [];
                if(this.el) this.el.innerHTML = '<div style="color:#666; text-align:center; padding:20px;">-- LOGS CLEARED --</div>';
                this.log('SYS', 'Logs cleared manually.');
            },
            toggleFilter: function(cat) {
                const btn = document.querySelector('.log-filter-btn.f-' + cat);
                if (btn) {
                    const isActive = btn.classList.toggle('active');
                    if (isActive) {
                        document.body.classList.remove('hide-log-' + cat);
                    } else {
                        document.body.classList.add('hide-log-' + cat);
                    }
                }
            }
        };

        // --- 物理定数 ---
        const V_MODEL = [{ d: 0,  vp: 5.8, vs: 3.4 }, { d: 20, vp: 6.6, vs: 3.8 }, { d: 30, vp: 8.0, vs: 4.6 }];
        const V_SURF = 3.1; 
        const RUPTURE_RATIO = 0.8;
        
        // --- システム変数 ---
        let stations = [];
        let cachedRenderQueue = [];
        let needsSort = true;
        let lastCamState = { x: 0, y: 0, zoom: 0 };
        let isIntNumberVisible = true;
        let quake = null; 
        let selectedStation = null; 
        let hoveredStation = null;
        let lastTime = 0; 
        let frameCount = 0;
        let currentStrike = 0;
        let audioCtx = null;
        let isRealDataMode = false;
        let comparisonMode = 0; 
        let isSimQuakeRunning = false;
        let simQuake = null;
        
        let isMuted = false, displayMode = 'max';
        let isStationVisible = true; 
        let isAvsView = false;
        
        // 地域震度モード用
        let isRegionIntMode = false;
        let isRegionIconVisible = true; 
        let regionMaxInts = new Map(); 
        let regionCenters = new Map(); 
        let regionIconAreas = []; 
        let settingsBackup = { st: true, plum: true };
        let lastReportUpdate = 0; 
        let isStationCircle = true; 
        
        let fullRealDataList = [], filteredRealDataList = [], realDataOffset = 0; const realDataLimit = 50;
        let epicenterFeatures = [];
        let realDataSubMode = 'api'; 
        let fullHistoryData = [];
        let isCustomMapLoaded = false, isCustomStationLoaded = false;

        // ESIM用
        let esimCanvas = null;          
        let isEsimVisible = false;      
        let esimGenerated = false;

        // PLUM/EEW用
        let isPlumMapVisible = true;
        let plumWarnedPrefs = new Set(); 
        let forecastWarnedPrefs = new Set(); 
        let plumTriggered = false; 
        let neighborMap = new Map(); 
        let prefPolygons = {};
        
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d', { alpha: false });
        let bgCanvas = document.createElement('canvas');
        let bgCtx = bgCanvas.getContext('2d');
        let width, height, dpr;
        
        // 仮想座標系
        const V_SIZE = 3500; 
        const GEO_BOUNDS = { minLon: 122.5, maxLon: 146.5, minLat: 23.5, maxLat: 46.2 };
        const cam = { x: 0, y: 0, zoom: 1.0 }; const targetCam = { x: 0, y: 0, zoom: 1.0 };

        // UI参照
        const magIn = document.getElementById('mag');
        const depIn = document.getElementById('depth');
        const spdIn = document.getElementById('speed');
        const rupIn = document.getElementById('rup-start');
        const ibRegion = document.getElementById('ib-region');
        const ibDepth = document.getElementById('ib-depth');
        const ibMag = document.getElementById('ib-mag');
        const infoBar = document.getElementById('info-bar');
        
        const statPanel = document.getElementById('stat-panel');
        const guideOverlay = document.getElementById('guide-overlay');
        const menuContainer = document.getElementById('menu-container');
        const viewPresets = document.getElementById('view-presets');
        const viewSettings = document.getElementById('view-settings');
        const viewReal = document.getElementById('view-real');
        const viewReport = document.getElementById('view-report');
        const viewStructure = document.getElementById('view-structure'); 
        const btnMore = document.getElementById('btn-more');
        const logOverlay = document.getElementById('log-overlay');

        function mercatorY(lat) { const rad = lat * Math.PI / 180; return Math.log(Math.tan(Math.PI / 4 + rad / 2)); }
        const MIN_MERC_Y = mercatorY(GEO_BOUNDS.minLat); const MAX_MERC_Y = mercatorY(GEO_BOUNDS.maxLat); const MERC_RANGE = MAX_MERC_Y - MIN_MERC_Y;
        function toVirtual(lon, lat) { const nLon = (lon - GEO_BOUNDS.minLon) / (GEO_BOUNDS.maxLon - GEO_BOUNDS.minLon); const my = mercatorY(lat); const nLat = (my - MIN_MERC_Y) / MERC_RANGE; return { x: nLon * V_SIZE, y: (1 - nLat) * V_SIZE }; }
        function toGeo(vx, vy) { const nLon = vx / V_SIZE; const lon = nLon * (GEO_BOUNDS.maxLon - GEO_BOUNDS.minLon) + GEO_BOUNDS.minLon; const nLat = 1 - (vy / V_SIZE); const my = nLat * MERC_RANGE + MIN_MERC_Y; const latRad = 2 * Math.atan(Math.exp(my)) - Math.PI / 2; const lat = latRad * 180 / Math.PI; return { lon, lat }; }

        let japanPath = new Path2D();

        function initMap() {
            dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr; canvas.height = height * dpr;
            bgCanvas.width = V_SIZE; bgCanvas.height = V_SIZE; 
            if (!isCustomMapLoaded && (!japanPath || (japanPath instanceof Path2D && !japanPath.ops))) { japanPath = new Path2D(); resetCamera(); }
            
            bgCtx.clearRect(0, 0, V_SIZE, V_SIZE); 
            bgCtx.fillStyle = '#050507'; bgCtx.fillRect(0, 0, V_SIZE, V_SIZE); 
            bgCtx.fillStyle = '#383b45'; bgCtx.fill(japanPath, 'evenodd'); 
            bgCtx.strokeStyle = '#505560'; bgCtx.lineWidth = 1; bgCtx.stroke(japanPath);
            
            const loadingEl = document.getElementById('loading'); if(loadingEl) loadingEl.style.display = 'none';
            if(!window.isLooping) { window.isLooping = true; requestAnimationFrame(loop); }
            sysLogger.log('SYS', `Map initialized. Size: ${width}x${height}`);
        }

        function checkAllLoaded() { 
            if(isCustomMapLoaded && isCustomStationLoaded) {
                document.getElementById('guide-overlay').classList.add('hidden'); 
            }
        }
        function safeJsonParse(text) { if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1); try { return JSON.parse(text.trim()); } catch(e) { throw new Error("JSON形式ではありません"); } }
        
        function loadMapFile(input) {
            const file = input.files[0]; if(!file) return;
            sysLogger.log('SYS', `Loading map file: ${file.name}`);
            const reader = new FileReader(); document.getElementById('loading').style.display = 'flex';
            reader.onload = function(e) { 
                setTimeout(() => { 
                    try { 
                        processGeoJSON(safeJsonParse(e.target.result)); 
                        // Hide button on success
                        document.getElementById('btn-load-map').style.display = 'none';
                    } catch(err) { 
                        document.getElementById('loading').style.display = 'none'; 
                        sysLogger.error('E-FILE-001', `Error loading map: ${err.message}`, err); 
                    } 
                }, 100); 
            };
            reader.readAsText(file, "UTF-8");
        }
        function processGeoJSON(data) {
            const newPath = new Path2D(); prefPolygons = {};
            let features = data.features || (data.type === 'Feature' ? [data] : []); if(!features.length && (data.type === 'Polygon' || data.type === 'MultiPolygon')) features = [{geometry:data}];
            let count = 0;
            features.forEach(f => {
                const geom = f.geometry; if (!geom) return;
                const polys = (geom.type === 'Polygon') ? [geom.coordinates] : (geom.type === 'MultiPolygon') ? geom.coordinates : [];
                const areaName = f.properties ? (f.properties.nam_ja || f.properties.name || f.properties.NAME) : null;
                polys.forEach(poly => {
                    const ring = poly[0]; if(!ring || ring.length === 0) return;
                    const start = toVirtual(ring[0][0], ring[0][1]); newPath.moveTo(start.x, start.y);
                    for(let i=1; i<ring.length; i++) { const p = toVirtual(ring[i][0], ring[i][1]); newPath.lineTo(p.x, p.y); }
                    newPath.closePath(); 
                    if (areaName) { 
                        const key = areaName.replace(/\s+/g, ''); 
                        if (!prefPolygons[key]) prefPolygons[key] = new Path2D(); 
                        const sub = prefPolygons[key]; 
                        sub.moveTo(start.x, start.y); for(let i=1; i<ring.length; i++) { const p = toVirtual(ring[i][0], ring[i][1]); sub.lineTo(p.x, p.y); } sub.closePath(); 
                    }
                    count++;
                });
            });
            document.getElementById('loading').style.display = 'none'; if(count === 0) { const msg = "有効なポリゴンなし"; sysLogger.error('E-FILE-002', msg, null); return; }
            japanPath = newPath; isCustomMapLoaded = true; 
            initMap(); checkAllLoaded();
            sysLogger.log('SYS', `Map loaded: ${count} polygons processed.`);
        }

        function loadStationFile(input) {
            const file = input.files[0]; if(!file) return;
            sysLogger.log('SYS', `Loading station file: ${file.name}`);
            const reader = new FileReader(); document.getElementById('loading').style.display = 'flex';
            reader.onload = function(e) { 
                setTimeout(() => { 
                    try { 
                        processStationData(safeJsonParse(e.target.result)); 
                        // Hide button on success
                        document.getElementById('btn-load-station').style.display = 'none';
                    } catch(err) { 
                        document.getElementById('loading').style.display = 'none'; 
                        sysLogger.error('E-FILE-003', `Error loading station: ${err.message}`, err); 
                    } 
                }, 100); 
            };
            reader.readAsText(file, "UTF-8");
        }
        function processStationData(data) {
            if (!Array.isArray(data)) throw new Error("配列形式ではありません");
            let newStations = []; const step = Math.ceil(data.length / 30000) || 1;
            regionCenters.clear();
            let areaSums = {}; 
            for(let i=0; i<data.length; i+=step) {
                const s = data[i]; if (!s) continue;
                const lat = parseFloat(s.lat||s.LAT||s.latitude), lon = parseFloat(s.lon||s.LON||s.longitude);
                if (!isNaN(lat) && !isNaN(lon)) {
                    const v = toVirtual(lon, lat);
                    const { avs, arv } = getStationPhysicsParams(s);
                    const code = s.code || `st_${i}`;
                    newStations.push({ index: i, code: code, name: s.name||s.NAME||"Unknown", vx: v.x, vy: v.y, lat, lon, currentInt: 0, maxInt: 0, amp: arv, avs: avs, tcode: s.TCODE || s.tcode, pref: s.pref, city: s.city, area: s.area });
                    
                    if (s.area && s.area.name) {
                        const key = s.area.name.replace(/\s+/g, '');
                        if (!areaSums[key]) areaSums[key] = { vx: 0, vy: 0, count: 0 };
                        areaSums[key].vx += v.x; areaSums[key].vy += v.y; areaSums[key].count++;
                    }
                }
            }
            for (let key in areaSums) { regionCenters.set(key, { vx: areaSums[key].vx / areaSums[key].count, vy: areaSums[key].vy / areaSums[key].count }); }
            if(newStations.length === 0) { const msg = "有効な観測点ゼロ"; throw new Error(msg); }
            stations = newStations;
            neighborMap.clear(); const DIST_LIMIT = 30.0;
            const grid = new Map();
            const cellSize = 0.5; 
            stations.forEach(s => {
                const gx = Math.floor(s.lon / cellSize), gy = Math.floor(s.lat / cellSize);
                const key = `${gx},${gy}`;
                if(!grid.has(key)) grid.set(key, []);
                grid.get(key).push(s);
            });

            for (let i = 0; i < stations.length; i++) {
                const s1 = stations[i]; const neighbors = []; const cosLat = Math.cos(s1.lat * Math.PI / 180);
                const gx = Math.floor(s1.lon / cellSize), gy = Math.floor(s1.lat / cellSize);
                
                for(let dx_g=-1; dx_g<=1; dx_g++) {
                    for(let dy_g=-1; dy_g<=1; dy_g++) {
                        const cell = grid.get(`${gx+dx_g},${gy+dy_g}`);
                        if(!cell) continue;
                        for(const s2 of cell) {
                            if(s1 === s2) continue;
                            const dx = (s2.lon - s1.lon) * 111 * cosLat; const dy = (s2.lat - s1.lat) * 111;
                            if (dx*dx + dy*dy <= DIST_LIMIT*DIST_LIMIT) neighbors.push(s2);
                        }
                    }
                }
                if(neighbors.length > 0) neighborMap.set(s1.code, neighbors);
            }
            document.getElementById('loading').style.display = 'none'; 
            isCustomStationLoaded = true; 
            resetSim(); switchTab('sim'); checkAllLoaded();
            sysLogger.log('SYS', `Station data loaded: ${stations.length} points.`);
        }
        function loadEpicenterFile(input) {
            const file = input.files[0]; if(!file) return;
            sysLogger.log('SYS', `Loading epicenter file: ${file.name}`);
            const reader = new FileReader(); document.getElementById('loading').style.display = 'flex';
            reader.onload = function(e) { 
                try { 
                    const json = safeJsonParse(e.target.result); 
                    epicenterFeatures = json.features || (json.type === 'FeatureCollection' ? json.features : [json]);
                    epicenterFeatures.forEach(f => {
                         if (!f.geometry) return;
                         const coords = f.geometry.coordinates;
                         let minX=180, maxX=-180, minY=90, maxY=-90;
                         const flat = (arr) => {
                             if(Array.isArray(arr[0])) arr.forEach(flat);
                             else {
                                 if(arr[0] < minX) minX=arr[0]; if(arr[0] > maxX) maxX=arr[0];
                                 if(arr[1] < minY) minY=arr[1]; if(arr[1] > maxY) maxY=arr[1];
                             }
                         };
                         flat(coords);
                         f.bbox = { minX, maxX, minY, maxY };
                    });
                    document.getElementById('loading').style.display = 'none'; 
                    // Hide button on success
                    document.getElementById('btn-load-epicenter').style.display = 'none';
                    sysLogger.log('SYS', `Epicenter data loaded: ${epicenterFeatures.length} features.`);
                } catch(err) { 
                    document.getElementById('loading').style.display = 'none'; 
                    sysLogger.error('E-FILE-004', `Error loading epicenter: ${err.message}`, err); 
                } 
            };
            reader.readAsText(file, "UTF-8");
        }
        function isPointInPolygon(point, vs) { const x = point[0], y = point[1]; let inside = false; for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) { const xi = vs[i][0], yi = vs[i][1], xj = vs[j][0], yj = vs[j][1]; const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi); if (intersect) inside = !inside; } return inside; }
        
        function getEpicenterName(lat, lon) {
            if (epicenterFeatures.length > 0) {
                for (const feature of epicenterFeatures) {
                    if (feature.bbox) { if (lon < feature.bbox.minX || lon > feature.bbox.maxX || lat < feature.bbox.minY || lat > feature.bbox.maxY) continue; }
                    const geom = feature.geometry; if (!geom) continue;
                    const polys = (geom.type === 'Polygon') ? [geom.coordinates] : (geom.type === 'MultiPolygon') ? geom.coordinates : [];
                    for (const poly of polys) { if (isPointInPolygon([lon, lat], poly[0])) return feature.properties.name || "名称不明"; }
                }
                return "領域外";
            }
            if (!stations || stations.length === 0) return "震源地不明";
            let closestSt = null, minDistSq = Infinity; for (let st of stations) { const d = (st.lon-lon)**2 + (st.lat-lat)**2; if(d < minDistSq) { minDistSq = d; closestSt = st; } }
            if(!closestSt) return "詳細不明"; const distKm = Math.sqrt(minDistSq) * 111;
            if (distKm < 20) return (closestSt.area && closestSt.area.name) ? closestSt.area.name : `${closestSt.pref ? closestSt.pref.name : ''} 付近`;
            const dx = lon - closestSt.lon, dy = lat - closestSt.lat; const angle = Math.atan2(dy, dx) * 180 / Math.PI; let dir = "西方"; if (angle >= -45 && angle < 45) dir = "東方"; else if (angle >= 45 && angle < 135) dir = "北方"; else if (angle >= -135 && angle < -45) dir = "南方";
            return `${closestSt.area ? closestSt.area.name : (closestSt.pref ? closestSt.pref.name : '')} ${dir}沖`;
        }

        // --- 物理演算系 ---
        function getStationPhysicsParams(st) {
            let avs = parseFloat(st.avs || st.AVS30); let arv = parseFloat(st.amp || st.ARV); const tcode = parseInt(st.tcode || st.TCODE);
            const tcodeAvsMap = { 1: 600, 2: 450, 3: 400, 7: 400, 8: 280, 9: 250, 10: 180, 11: 140, 12: 130, 14: 120, 16: 130, 19: 150 };
            if (isNaN(avs) || avs <= 0) { if (tcodeAvsMap[tcode]) avs = tcodeAvsMap[tcode]; else avs = (arv > 0) ? 600 / Math.pow(arv, 1.1) : 350; }
            if (isNaN(arv) || arv <= 0) arv = Math.pow(600 / avs, 0.9);
            return { avs, arv };
        }
        function calculateNonLinearAmplification(pgvBed, avs30, linearArv) {
            if (pgvBed <= 8.0) return linearArv;
            const softnessIndex = Math.max(0, (600 - avs30) / 600); if (softnessIndex <= 0.05) return linearArv;
            const excessInput = Math.log10(pgvBed / 8.0); const reduction = 0.35 * softnessIndex * excessInput;
            return linearArv * Math.max(0.35, 1.0 - reduction);
        }
        function getPlateAttenuationFactor(qLat, qLon, depth, stLat, stLon) {
            if (depth < 60) return 1.0;
            const isPacificSide = (stLon > 138 && stLat > 34 && stLon > (stLat * 1.5 + 85));
            return isPacificSide ? 1.0 + (depth - 60) * 0.006 : 1.0;
        }
        function getDirectivityFactor(qLat, qLon, strike, stLat, stLon, startRatio) {
            if (startRatio === undefined || startRatio === null) return 1.0;
            const dy = stLat - qLat; const dx = (stLon - qLon) * Math.cos(qLat * Math.PI / 180);
            const azimuth = Math.atan2(dx, dy) * 180 / Math.PI; let angleDiff = Math.abs(azimuth - strike); if (angleDiff > 180) angleDiff = 360 - angleDiff;
            const directivity = Math.cos(angleDiff * Math.PI / 180); return 1.0 + (directivity * 0.3 * startRatio);
        }
        function getTravelTime(distKm, depthKm, waveType) { 
            const distHypo = Math.sqrt(distKm**2 + depthKm**2); let avgV = 0; 
            if (depthKm < 20) { avgV = (waveType === 'p') ? V_MODEL[0].vp : V_MODEL[0].vs; } 
            else if (depthKm < 50) { const v1 = (waveType === 'p') ? V_MODEL[0].vp : V_MODEL[0].vs; const v2 = (waveType === 'p') ? V_MODEL[1].vp : V_MODEL[1].vs; avgV = (v1 * 20 + v2 * (depthKm - 20)) / depthKm; } 
            else { const vC = (waveType === 'p') ? 6.5 : 3.7; const vM = (waveType === 'p') ? V_MODEL[2].vp : V_MODEL[2].vs; const mantleRatio = (depthKm - 30) / depthKm; avgV = vC * (1 - mantleRatio) + vM * mantleRatio; } 
            if (distKm > depthKm * 2 && depthKm > 30) { const vM = (waveType === 'p') ? V_MODEL[2].vp : V_MODEL[2].vs; avgV = avgV * 0.4 + vM * 0.6; } 
            return distHypo / avgV; 
        }
        
        function getDistToSegmentSq(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2; if (l2 === 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2; t = Math.max(0, Math.min(1, t));
            return (p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2;
        }

        function calculateIntensity(mag, depth, distHypoKm, arv, stLat, stLon, qLat, qLon, strike, isFault, startRatio, avs) { 
            const mw = (mag > 7.5) ? mag - 0.2 : mag; 
            const c = 0.0025 * Math.pow(10, 0.50 * mw); const x = distHypoKm + c;
            const logPgvB = 0.58 * mw + 0.0038 * depth - 1.29 - Math.log10(x) - 0.0024 * x;
            let pgvBed = Math.pow(10, logPgvB);
            pgvBed *= getPlateAttenuationFactor(qLat, qLon, depth, stLat, stLon);

            if (distHypoKm < 25) {
                const nearBoost = 1.0 + (25 - distHypoKm) / 25 * 0.35; 
                pgvBed *= nearBoost;
            }

            if (isFault) {
                let dFactor = getDirectivityFactor(qLat, qLon, strike, stLat, stLon, startRatio); if (mag < 6.5) dFactor = 1.0 + (dFactor - 1.0) * 0.5; pgvBed *= dFactor;
            } else { 
                const dy = stLat - qLat, dx = (stLon - qLon) * Math.cos(qLat * Math.PI / 180); 
                const azimuth = Math.atan2(dx, dy) * 180 / Math.PI; let angleDiff = Math.abs((azimuth - strike) * Math.PI / 180); 
                
                let dirFactor = (0.6 + 0.4 * Math.abs(Math.sin(2 * angleDiff)));
                if (distHypoKm < 25) {
                    const relaxRatio = (25 - distHypoKm) / 25;
                    dirFactor = dirFactor * (1 - relaxRatio) + 1.0 * relaxRatio; 
                }
                pgvBed *= dirFactor; 
            }
            const finalArv = calculateNonLinearAmplification(pgvBed, avs, arv);
            const pgvSurf = pgvBed * finalArv;
            let intensity = 2.68 + 1.72 * Math.log10(pgvSurf);
            if (intensity > 7.5) intensity = 7.5 + (intensity - 7.5) * 0.1;
            return Math.max(0, intensity);
        }
        function applyShindoLimiter(raw) { 
            if (raw < 6.0) return raw; 
            return 6.0 + (raw - 6.0) * 0.7; 
        }
        
        function startQuake(lat, lon, mag, depth, ruptureStartRatio = 0.0, faultLenKm = 0) {
            if (!stations || stations.length === 0) {
                const msg = "Cannot start simulation: No stations loaded.";
                // Alert removed, logging only
                sysLogger.error('E-SIM-001', msg, null);
                return;
            }

            sysLogger.log('SIM', `StartQuake: M${mag} D${depth}km @(${lat.toFixed(3)}, ${lon.toFixed(3)})`);
            initAudio(); const v = toVirtual(lon, lat);
            let L_km = faultLenKm; if(L_km === 0 && mag >= 6.0) L_km = Math.pow(10, 0.6 * mag - 2.9); if(mag < 6.0) L_km = 0;
            
            const baseScale = V_SIZE / 2400; 
            const baseLatRad = 36 * Math.PI / 180;
            const currentLatRad = lat * Math.PI / 180;
            const mercatorFactor = Math.cos(baseLatRad) / Math.cos(currentLatRad);
            const localKmToPx = baseScale * mercatorFactor;

            const L_px = L_km * localKmToPx; 
            const theta = (currentStrike - 90) * Math.PI / 180;
            const rupSpeed = 3.5 * RUPTURE_RATIO; const maxLenKm = Math.max(ruptureStartRatio, 1.0 - ruptureStartRatio) * L_km;
            const durationSec = (L_km > 0) ? maxLenKm / rupSpeed : 0;
            
            const fX1 = v.x - Math.cos(theta) * (L_px * ruptureStartRatio), fY1 = v.y - Math.sin(theta) * (L_px * ruptureStartRatio);
            const fX2 = v.x + Math.cos(theta) * (L_px * (1.0 - ruptureStartRatio)), fY2 = v.y + Math.sin(theta) * (L_px * (1.0 - ruptureStartRatio));
            
            quake = { 
                lat, lon, vx: v.x, vy: v.y, mag, depth, strike: currentStrike, 
                startTime: performance.now(), 
                simulationTimeElapsed: 0, 
                isFault: L_km > 5, fLengthKm: L_km, ruptureDur: durationSec, rRatio: ruptureStartRatio, 
                fX1, fY1, fX2, fY2, 
                displayMag: mag, displayDep: depth,
                firstTriggerDone: false, 
                minPTime: Infinity,      
                nextEEWCheck: 0,
                firstObservationTime: null,
                eewYellowTriggered: false,
                plumOnlyMode: false,
                plumTriggered: false,
                nextPlumUpdate: 3.0,
            };
            
            quake.cachedDists = new Float32Array(stations.length);
            quake.cachedPArrivals = new Float32Array(stations.length);
            quake.cachedSArrivals = new Float32Array(stations.length);
            quake.cachedTargetInts = new Float32Array(stations.length);

            const rad = Math.PI / 180;
            const qLatRad = lat * rad, qLonRad = lon * rad;
            const sinLat1 = Math.sin(qLatRad), cosLat1 = Math.cos(qLatRad);

            stations.forEach((st, i) => {
                st.currentInt = 0; st.maxInt = 0;
                const stLatRad = st.lat * rad, stLonRad = st.lon * rad;
                const cosCentralAngle = sinLat1 * Math.sin(stLatRad) + cosLat1 * Math.cos(stLatRad) * Math.cos(stLonRad - qLonRad);
                const clampedCos = Math.max(-1.0, Math.min(1.0, cosCentralAngle));
                const distEpicenterKm = Math.acos(clampedCos) * 6371;
                quake.cachedDists[i] = distEpicenterKm;
                const pArr = getTravelTime(distEpicenterKm, depth, 'p');
                quake.cachedPArrivals[i] = pArr;
                quake.cachedSArrivals[i] = getTravelTime(distEpicenterKm, depth, 's');
                if (pArr < quake.minPTime) quake.minPTime = pArr;

                let distForShakeKm = distEpicenterKm;
                if (quake.isFault) {
                    const dPxSq = getDistToSegmentSq({x: st.vx, y: st.vy}, {x: fX1, y: fY1}, {x: fX2, y: fY2});
                    const dPx = Math.sqrt(dPxSq);
                    distForShakeKm = dPx / localKmToPx; 
                }
                const distHypoDirect = Math.sqrt(distForShakeKm**2 + depth**2);
                quake.cachedTargetInts[i] = calculateIntensity(mag, depth, distHypoDirect, st.amp, st.lat, st.lon, lat, lon, currentStrike, quake.isFault, ruptureStartRatio, st.avs);
            });

            plumWarnedPrefs.clear(); forecastWarnedPrefs.clear(); plumTriggered = false;
            ibRegion.innerText = getEpicenterName(lat, lon); ibDepth.innerText = depth + "km"; ibMag.innerText = "M" + mag.toFixed(1); infoBar.className = "warning"; 

            if(!isUserInteracting) { targetCam.x = v.x; targetCam.y = v.y; targetCam.zoom = Math.min(width, height) / (L_px > 0 ? Math.max(L_px * 2.5, 150) : 150); }
            
            switchTab('sim'); guideOverlay.classList.add('hidden'); 
            playTone(audioCtx.currentTime, 660, 0.2, "triangle"); playTone(audioCtx.currentTime, 523, 0.2, "triangle");
            
            document.getElementById('report-content').innerHTML = `<div style="text-align:center; padding:30px; color:#888;"><div>Simulating...</div><div style="font-size:0.8rem; margin-top:5px;">Wave is propagating.</div></div>`; lastReportUpdate = 0; 
            document.getElementById('esim-control').style.display = 'flex'; document.getElementById('btn-toggle-esim').classList.remove('active'); esimGenerated = false; isEsimVisible = false; 
            sysLogger.log('SIM', 'Pre-calculation finished. Simulation running.');
        }

        function generateReport(qObj) {
            if (!stations || stations.length === 0) return `<div style="text-align:center; padding:30px; color:#888;">No Station Data Loaded</div>`;
            const results = stations.map(st => {
                const intVal = st.maxInt; let iClass = "0";
                if(intVal>=6.5) iClass="7"; else if(intVal>=6.0) iClass="6+"; else if(intVal>=5.5) iClass="6-";
                else if(intVal>=5.0) iClass="5+"; else if(intVal>=4.5) iClass="5-"; else if(intVal>=3.5) iClass="4";
                else if(intVal>=2.5) iClass="3"; else if(intVal>=1.5) iClass="2"; else if(intVal>=0.5) iClass="1";
                return { name: st.name, pref: st.pref, intVal: intVal, iClass: iClass };
            });
            const filtered = results.filter(r => r.intVal >= 0.5); 
            const tempSorted = [...filtered].sort((a,b) => b.intVal - a.intVal);
            const maxIntClass = tempSorted.length > 0 ? tempSorted[0].iClass : "-";
            if(filtered.length === 0) return `<div style="text-align:center; padding:30px; color:#888;"><div>Monitoring...</div><div style="font-size:0.8rem; margin-top:5px;">Wave is propagating.</div></div>`;
            let html = "";
            const classes = ["7", "6+", "6-", "5+", "5-", "4", "3", "2", "1"];
            const classColors = { "7":"bg-7", "6+":"bg-6p", "6-":"bg-6m", "5+":"bg-5p", "5-":"bg-5m", "4":"bg-4", "3":"bg-3", "2":"bg-2", "1":"bg-1" };
            const regionName = document.getElementById('ib-region').innerText;
            html += `<div class="report-info-box"><div><span class="ri-label">HYPOCENTER</span><br><span class="ri-val">${regionName}</span></div><div><span class="ri-label">OBSERVED MAX</span><br><span class="ri-val">${maxIntClass}</span></div><div><span class="ri-label">MAGNITUDE</span><br><span class="ri-val">M${qObj.mag.toFixed(1)}</span></div><div><span class="ri-label">DEPTH</span><br><span class="ri-val">${qObj.depth}km</span></div></div>`;
            classes.forEach(cls => {
                let targets = filtered.filter(r => r.iClass === cls);
                if(targets.length === 0) return;
                targets.sort((a, b) => { const cA = a.pref ? a.pref.code : 99; const cB = b.pref ? b.pref.code : 99; if (cA !== cB) return cA - cB; return b.intVal - a.intVal; });
                html += `<div class="report-section"><div class="report-header"><div class="r-int-icon ${classColors[cls]}">${cls}</div><div class="r-title">震度${cls}</div></div>`;
                let currentPref = -1;
                targets.forEach(t => {
                    const pCode = t.pref ? t.pref.code : 99; const pName = t.pref ? t.pref.name : "その他";
                    if(pCode !== currentPref) { if(currentPref !== -1) html += `</div></div>`; html += `<div class="pref-block"><div class="pref-name">${pName}</div><div class="st-list">`; currentPref = pCode; }
                    html += `<div class="st-tag">${t.name}<span class="st-val">${t.intVal.toFixed(1)}</span></div>`;
                });
                html += `</div></div></div>`; 
            });
            return html;
        }

        function generateESIM() {
            const activeStations = stations.filter(st => st.maxInt >= 1.5);
            if (!japanPath || activeStations.length === 0) { if (esimCanvas) { esimCanvas = null; isEsimVisible = false; } return; }
            sysLogger.log('SYS', 'Generating E-Sim mesh...');
            const calcScale = 0.8; const vW = Math.ceil(V_SIZE * calcScale); const vH = Math.ceil(V_SIZE * calcScale);
            const calcCanvas = document.createElement('canvas'); calcCanvas.width = vW; calcCanvas.height = vH;
            const cCtx = calcCanvas.getContext('2d'); const imgData = cCtx.createImageData(vW, vH); const data = imgData.data;
            const targets = activeStations.map(st => ({ x: st.vx * calcScale, y: st.vy * calcScale, int: st.maxInt }));
            let minX = vW, maxX = 0, minY = vH, maxY = 0; const padding = 220 * calcScale; 
            targets.forEach(t => { if (t.x < minX) minX = t.x; if (t.x > maxX) maxX = t.x; if (t.y < minY) minY = t.y; if (t.y > maxY) maxY = t.y; });
            minX = Math.max(0, Math.floor(minX - padding)); maxX = Math.min(vW, Math.ceil(maxX + padding)); minY = Math.max(0, Math.floor(minY - padding)); maxY = Math.min(vH, Math.ceil(maxY + padding));
            const radius = 215 * calcScale; const radiusSq = radius * radius; const cutoffDistSq = 14500 * (calcScale * calcScale);
            for (let y = minY; y < maxY; y++) {
                const yOffset = y * vW;
                for (let x = minX; x < maxX; x++) {
                    let num = 0, den = 0; let minDistSq = Infinity; const lLim = x - radius, rLim = x + radius, tLim = y - radius, bLim = y + radius;
                    for (let i = 0, len = targets.length; i < len; i++) {
                        const t = targets[i]; if (t.x < lLim || t.x > rLim || t.y < tLim || t.y > bLim) continue;
                        const dx = t.x - x, dy = t.y - y; const distSq = dx*dx + dy*dy; 
                        if (distSq > radiusSq) continue; if (distSq < 0.01) { num = t.int; den = 1; minDistSq = 0; break; }
                        const weight = 1.0 / distSq; num += t.int * weight; den += weight; if (distSq < minDistSq) minDistSq = distSq;
                    }
                    if (den > 0 && minDistSq < cutoffDistSq) {
                        const val = num / den;
                        if (val >= 3.5) { const c = getSolidColor(val); const idx = (yOffset + x) * 4; data[idx] = c.r; data[idx + 1] = c.g; data[idx + 2] = c.b; data[idx + 3] = 255; }
                    }
                }
            }
            cCtx.putImageData(imgData, 0, 0); 
            esimCanvas = document.createElement('canvas'); esimCanvas.width = V_SIZE; esimCanvas.height = V_SIZE; 
            const eCtx = esimCanvas.getContext('2d'); eCtx.imageSmoothingEnabled = false; eCtx.drawImage(calcCanvas, 0, 0, V_SIZE, V_SIZE); 
            eCtx.globalCompositeOperation = 'destination-in'; eCtx.fillStyle = '#fff'; eCtx.fill(japanPath, 'evenodd'); 
            eCtx.globalCompositeOperation = 'source-over'; eCtx.lineWidth = 0.5; eCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; eCtx.stroke(japanPath); 
            esimGenerated = true; isEsimVisible = true;
            document.getElementById('btn-toggle-esim').classList.add('active'); document.getElementById('btn-toggle-esim').style.borderColor = '#ffeb3b'; document.getElementById('btn-toggle-esim').style.color = '#ffeb3b';
        }
        function getSolidColor(v) { 
            if(v >= 6.5) return {r:180, g:0, b:104}; if(v >= 6.0) return {r:165, g:0, b:33}; if(v >= 5.5) return {r:255, g:40, b:0}; 
            if(v >= 5.0) return {r:255, g:153, b:0}; if(v >= 4.5) return {r:255, g:255, b:0}; if(v >= 3.5) return {r:242, g:231, b:0}; 
            if(v >= 2.5) return {r:0, g:65, b:255}; if(v >= 1.5) return {r:0, g:170, b:255}; return {r:242, g:242, b:255}; 
        }
        
        window.toggleESIM = function() {
            if (!esimGenerated) { document.getElementById('btn-toggle-esim').innerHTML = '<span class="loader" style="width:12px; height:12px; border-width:2px; display:inline-block;"></span>'; setTimeout(() => { generateESIM(); document.getElementById('btn-toggle-esim').innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 3v18h18M7 16l4-4 4 4 5-8"></path></svg><span>推計震度分布</span>'; }, 10); } 
            else { isEsimVisible = !isEsimVisible; const btn = document.getElementById('btn-toggle-esim'); if (isEsimVisible) { btn.classList.add('active'); btn.style.background = 'rgba(255, 235, 59, 0.15)'; } else { btn.classList.remove('active'); btn.style.background = 'rgba(0,0,0,0.6)'; } }
        };
        function toggleStations() { isStationVisible = !isStationVisible; const btn = document.getElementById('btn-toggle-st'); if(isStationVisible) { btn.classList.add('active'); btn.style.background = 'rgba(255, 235, 59, 0.15)'; btn.style.color = '#ffeb3b'; btn.style.borderColor = '#ffeb3b'; } else { btn.classList.remove('active'); btn.style.background = 'rgba(0, 0, 0, 0.6)'; btn.style.color = '#aaa'; btn.style.borderColor = '#444'; } }
        function togglePLUM() { isPlumMapVisible = !isPlumMapVisible; const btn = document.getElementById('btn-toggle-plum'); if(isPlumMapVisible) { btn.classList.add('active'); btn.style.background = 'rgba(255, 235, 59, 0.15)'; btn.style.color = '#ffeb3b'; btn.style.borderColor = '#ffeb3b'; } else { btn.classList.remove('active'); btn.style.background = 'rgba(0,0,0,0.6)'; btn.style.color = '#aaa'; btn.style.borderColor = '#444'; } }
        function toggleAVSView() {
            needsSort = true; isAvsView = !isAvsView; const btn = document.getElementById('btn-toggle-avs'); if(isAvsView) { btn.classList.add('active'); btn.style.background = 'rgba(255, 235, 59, 0.15)'; btn.style.color = '#ffeb3b'; btn.style.borderColor = '#ffeb3b'; } else { btn.classList.remove('active'); btn.style.background = 'rgba(0,0,0,0.6)'; btn.style.color = '#aaa'; btn.style.borderColor = '#444'; } }
        
        function setStationShape(isCircle) {
            isStationCircle = isCircle;
            const btnC = document.getElementById('btn-shape-circle');
            const btnR = document.getElementById('btn-shape-rect');
            if(isCircle) { btnC.classList.add('active'); btnR.classList.remove('active'); }
            else { btnR.classList.add('active'); btnC.classList.remove('active'); }
        }
        function setIntNumberVisible(visible) {
            isIntNumberVisible = visible;
            const btnOn = document.getElementById('btn-int-num-on');
            const btnOff = document.getElementById('btn-int-num-off');
            if(visible) { btnOn.classList.add('active'); btnOff.classList.remove('active'); }
            else { btnOff.classList.add('active'); btnOn.classList.remove('active'); }
        }

        function setRegionIntMode(on) { 
            if (isRegionIntMode === on) return;
            if (on) {
                settingsBackup.st = isStationVisible;
                settingsBackup.plum = isPlumMapVisible;
                isStationVisible = false; isPlumMapVisible = false;
                document.getElementById('btn-toggle-region-icons').style.display = 'flex';
            } else {
                isStationVisible = settingsBackup.st;
                isPlumMapVisible = settingsBackup.plum;
                document.getElementById('btn-toggle-region-icons').style.display = 'none';
                document.getElementById('region-popup').style.display = 'none';
            }
            isRegionIntMode = on; 
            document.getElementById('btn-mode-region-on').classList.toggle('active', on); 
            document.getElementById('btn-mode-region-off').classList.toggle('active', !on);
            
            const btnSt = document.getElementById('btn-toggle-st');
            if (isStationVisible) { btnSt.classList.add('active'); btnSt.style.background = 'rgba(255, 235, 59, 0.15)'; btnSt.style.color = '#ffeb3b'; btnSt.style.borderColor = '#ffeb3b'; }
            else { btnSt.classList.remove('active'); btnSt.style.background = 'rgba(0,0,0,0.6)'; btnSt.style.color = '#aaa'; btnSt.style.borderColor = '#444'; }
            
            const btnPlum = document.getElementById('btn-toggle-plum');
            if (isPlumMapVisible) { btnPlum.classList.add('active'); btnPlum.style.background = 'rgba(255, 235, 59, 0.15)'; btnPlum.style.color = '#ffeb3b'; btnPlum.style.borderColor = '#ffeb3b'; }
            else { btnPlum.classList.remove('active'); btnPlum.style.background = 'rgba(0,0,0,0.6)'; btnPlum.style.color = '#aaa'; btnPlum.style.borderColor = '#444'; }
        }

        function getAVSColor(avs) { if (avs < 150) return '#b71c1c'; if (avs < 250) return '#d32f2f'; if (avs < 350) return '#f57f17'; if (avs < 450) return '#fbc02d'; if (avs < 600) return '#8bc34a'; if (avs < 800) return '#00acc1'; return '#1a237e'; }

        function triggerPreset(lat, lon, mag, depth, strike, len, ratio) { magIn.value = mag; depIn.value = depth; setStrike(strike); rupIn.value = ratio; updateDisplay(); resetSim(); setTimeout(() => { startQuake(lat, lon, mag, depth, ratio, len); }, 0); }
        function updateDisplay() { document.getElementById('d-mag').innerText = parseFloat(magIn.value).toFixed(1); document.getElementById('d-dep').innerText = depIn.value + "km"; document.getElementById('d-spd').innerText = "x" + parseFloat(spdIn.value).toFixed(1); const r = parseFloat(rupIn.value); document.getElementById('d-rup').innerText = r.toFixed(1) + (r===0?" (END)":r===0.5?" (CENTER)":r===1?" (END)":""); }
        function adjustSpeed(d) { const el = document.getElementById('speed'); let v = parseFloat(el.value) + d; if(v < parseFloat(el.min)) v = parseFloat(el.min); if(v > parseFloat(el.max)) v = parseFloat(el.max); el.value = v.toFixed(1); updateDisplay(); }
        function adjustParam(id, d) { const el = document.getElementById(id); let v = parseFloat(el.value)+d; if(v<parseFloat(el.min))v=parseFloat(el.min); if(v>parseFloat(el.max))v=parseFloat(el.max); if(id==='mag')v=Math.round(v*10)/10; el.value=v; updateDisplay(); }
        function getIntStr(v) { if(v>=6.5)return"7"; if(v>=6.0)return"6+"; if(v>=5.5)return"6-"; if(v>=5.0)return"5+"; if(v>=4.5)return"5-"; return Math.round(v).toString(); }
        function getIntColor(v) { if(v<0.5)return'#555';if(v<1.5)return'#46bc9c';if(v<2.5)return'#e6d836';if(v<3.5)return'#f09d26';if(v<4.5)return'#f04f26';if(v<5.0)return'#d61a6c';if(v<5.5)return'#a50021';if(v<6.0)return'#8c1a1a';if(v<6.5)return'#7f0d0d';return'#7c1a8c'; }
        function getIntLevel(v) { if(v>=6.5)return 9; if(v>=6.0)return 8; if(v>=5.5)return 7; if(v>=5.0)return 6; if(v>=4.5)return 5; return Math.round(v); }
        function getLevelColor(lv) { const colors = ['#555', '#46bc9c', '#e6d836', '#f09d26', '#f04f26', '#d61a6c', '#a50021', '#8c1a1a', '#7f0d0d', '#7c1a8c']; return colors[Math.min(9, Math.max(0, lv))]; }
        
        function updateInfoBarVisuals() {}
        
        function resetSim() {
            needsSort = true; 
            quake = null; isRealDataMode = false; statPanel.style.display = 'none'; 
            regionMaxInts.clear(); document.getElementById('region-popup').style.display = 'none';
            stations.forEach(st => { st.currentInt = 0; st.maxInt = 0; st.simInt = 0; st.simMaxInt = 0; }); resetCamera(); isUserInteracting = false; selectedStation = null; 
            if(!isCustomMapLoaded || !isCustomStationLoaded) guideOverlay.classList.remove('hidden'); document.getElementById('report-content').innerHTML = '<div style="text-align:center; color:#666; padding:30px;"><div>Waiting for Event...</div></div>'; esimGenerated = false; esimCanvas = null; isEsimVisible = false; 
            plumWarnedPrefs.clear(); forecastWarnedPrefs.clear(); plumTriggered = false; 
            document.getElementById('esim-control').style.display = 'none'; document.getElementById('btn-toggle-esim').innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 3v18h18M7 16l4-4 4 4 5-8"></path></svg><span>推計震度分布</span>'; 
            ibRegion.innerText = "---"; ibDepth.innerText = "---"; ibMag.innerText = "---"; infoBar.className = ""; 
            quake = null; comparisonMode = 0; isSimQuakeRunning = false; simQuake = null;
            document.getElementById('btn-comparison').style.display = 'none';
            sysLogger.log('SYS', 'Simulation reset.');
        }

        function toggleComparisonMode() {
            if (!isRealDataMode || !quake) return;
            comparisonMode = (comparisonMode + 1) % 4;
            const btn = document.getElementById('btn-comparison');
            if (comparisonMode === 1) {
                btn.innerText = 'MODE: SIMULATION';
                btn.style.background = 'rgba(255, 80, 80, 0.8)';
                btn.style.color = '#fff';
                if (!isSimQuakeRunning) startSimQuakeFromReal();
            } else if (comparisonMode === 2) {
                btn.innerText = 'MODE: HALF & HALF';
                btn.style.background = 'rgba(255, 215, 0, 0.8)';
                btn.style.color = '#000';
            } else if (comparisonMode === 3) {
                btn.innerText = 'MODE: ERROR COMP';
                btn.style.background = 'rgba(0, 255, 128, 0.8)';
                btn.style.color = '#000';
            } else {
                btn.innerText = 'SIMULATE THIS EVENT';
                btn.style.background = 'rgba(0, 170, 255, 0.8)';
                btn.style.color = '#fff';
            }
        }

        function startSimQuakeFromReal() {
            if (!quake) return;
            isSimQuakeRunning = true;
            const mag = quake.mag, depth = quake.depth, lat = quake.lat, lon = quake.lon;
            let L_km = (mag >= 6.0) ? Math.pow(10, 0.6 * mag - 2.9) : 0;
            const baseScale = V_SIZE / 2400; 
            const baseLatRad = 36 * Math.PI / 180;
            const currentLatRad = lat * Math.PI / 180;
            const localKmToPx = baseScale * (Math.cos(baseLatRad) / Math.cos(currentLatRad));
            const L_px = L_km * localKmToPx;
            const theta = (currentStrike - 90) * Math.PI / 180;
            const fX1 = quake.vx - Math.cos(theta) * (L_px * 0.5), fY1 = quake.vy - Math.sin(theta) * (L_px * 0.5);
            const fX2 = quake.vx + Math.cos(theta) * (L_px * 0.5), fY2 = quake.vy + Math.sin(theta) * (L_px * 0.5);

            simQuake = {
                lat, lon, vx: quake.vx, vy: quake.vy, mag, depth, strike: currentStrike,
                startTime: performance.now(), simulationTimeElapsed: 0,
                isFault: L_km > 5, fLengthKm: L_km, fX1, fY1, fX2, fY2,
                cachedDists: new Float32Array(stations.length),
                cachedPArrivals: new Float32Array(stations.length),
                cachedSArrivals: new Float32Array(stations.length),
                cachedTargetInts: new Float32Array(stations.length)
            };

            stations.forEach((st, i) => {
                st.simInt = 0; st.simMaxInt = 0;
                const rad = Math.PI / 180;
                const dEpicenterKm = Math.acos(Math.sin(lat*rad)*Math.sin(st.lat*rad) + Math.cos(lat*rad)*Math.cos(st.lat*rad)*Math.cos((st.lon-lon)*rad)) * 6371;
                simQuake.cachedDists[i] = dEpicenterKm;
                simQuake.cachedPArrivals[i] = getTravelTime(dEpicenterKm, depth, 'p');
                simQuake.cachedSArrivals[i] = getTravelTime(dEpicenterKm, depth, 's');
                let distForShakeKm = dEpicenterKm;
                if (simQuake.isFault) {
                    const dPx = Math.sqrt(getDistToSegmentSq({x: st.vx, y: st.vy}, {x: fX1, y: fY1}, {x: fX2, y: fY2}));
                    distForShakeKm = dPx / localKmToPx;
                }
                simQuake.cachedTargetInts[i] = calculateIntensity(mag, depth, Math.sqrt(distForShakeKm**2 + depth**2), st.amp, st.lat, st.lon, lat, lon, currentStrike, simQuake.isFault, 0.5, st.avs);
            });
            sysLogger.log('SIM', 'Comparison simulation started.');
        }
        function initAudio() { if (!audioCtx) { try { const AC = window.AudioContext || window.webkitAudioContext; if(AC) audioCtx = new AC(); } catch(e) {} } if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }
        function playTone(time, freq, duration, type) { if(isMuted || !audioCtx) return; try { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = type; osc.frequency.value = freq; gain.gain.setValueAtTime(0.1, time); gain.gain.exponentialRampToValueAtTime(0.001, time + duration); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(time); osc.stop(time + duration); } catch(e) {} }
        function toggleMute() { 
            initAudio(); 
            isMuted = !isMuted; 
            const btn = document.getElementById('q-mute'); 
            const svg = document.getElementById('svg-mute');
            if(isMuted) { 
                btn.classList.add("muted-active"); 
                svg.innerHTML = '<path d="M11 5L6 9H2v6h4l5 4V5zM23 9l-6 6M17 9l6 6"></path>';
            } else { 
                btn.classList.remove("muted-active"); 
                svg.innerHTML = '<path d="M11 5L6 9H2v6h4l5 4V5zM19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>';
                if(audioCtx) playTone(audioCtx.currentTime, 880, 0.1, "sine"); 
            }
        }
        function toggleRegionIcons() {
            isRegionIconVisible = !isRegionIconVisible;
            const btn = document.getElementById('btn-toggle-region-icons');
            if (isRegionIconVisible) {
                btn.classList.remove('inactive');
                btn.style.background = 'rgba(0, 170, 255, 0.2)';
                btn.style.borderColor = '#00aaff';
                btn.style.color = '#00aaff';
            } else {
                btn.classList.add('inactive');
                btn.style.background = 'rgba(0, 0, 0, 0.6)';
                btn.style.borderColor = '#444';
                btn.style.color = '#888';
                document.getElementById('region-popup').style.display = 'none';
            }
        }

        let lastLogTime = 0;
        function loop(time) {
            const dt_real = (time - lastTime) / 1000; lastTime = time; const playSpeed = parseFloat(spdIn.value); const lerp = 0.2; frameCount++;
            
            if (!window.lastPerfLog || time - window.lastPerfLog > 2000) {
                 const fps = Math.round(1 / (dt_real || 0.016));
                 const objCount = stations ? stations.length : 0;
                 sysLogger.log('PERF', `FPS: ${fps} | Active Objs: ${objCount} | Zoom: ${cam.zoom.toFixed(2)}`);
                 window.lastPerfLog = time;
            }

            if(quake && !isRealDataMode) updateInfoBarVisuals();

            cam.x += (targetCam.x - cam.x) * lerp; cam.y += (targetCam.y - cam.y) * lerp; cam.zoom += (targetCam.zoom - cam.zoom) * lerp;

            ctx.fillStyle = '#050507'; ctx.fillRect(0, 0, width*dpr, height*dpr); 
            ctx.save(); 
            ctx.scale(dpr, dpr); ctx.translate(width/2, height/2); ctx.scale(cam.zoom, cam.zoom); ctx.translate(-cam.x, -cam.y);
            
            ctx.drawImage(bgCanvas, 0, 0, V_SIZE, V_SIZE); 
            ctx.lineWidth = 1/cam.zoom; ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.beginPath();
            for (let lon = 122; lon <= 146; lon += 2) { const s = toVirtual(lon, 20), e = toVirtual(lon, 48); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); } 
            for (let lat = 24; lat <= 46; lat += 2) { const s = toVirtual(120, lat), e = toVirtual(150, lat); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); } 
            ctx.stroke();
            
            if (esimGenerated && isEsimVisible && esimCanvas) ctx.drawImage(esimCanvas, 0, 0, V_SIZE, V_SIZE);

            if (isRegionIntMode) {
                regionMaxInts.clear();
                stations.forEach(st => {
                    if (st.area && st.maxInt >= 2.5) {
                        const key = st.area.name.replace(/\s+/g, '');
                        if (!regionMaxInts.has(key)) regionMaxInts.set(key, { maxInt: st.maxInt, name: st.area.name });
                        else { const r = regionMaxInts.get(key); if (st.maxInt > r.maxInt) r.maxInt = st.maxInt; }
                    }
                });
                regionMaxInts.forEach((r, key) => {
                    const path = prefPolygons[key];
                    if (path) {
                        ctx.fillStyle = getIntColor(r.maxInt) + "CC";
                        ctx.fill(path, 'evenodd');
                        ctx.strokeStyle = "rgba(255,255,255,0.3)";
                        ctx.lineWidth = 1.0 / cam.zoom;
                        ctx.stroke(path);
                    }
                });
            }

            if(quake && !isRealDataMode && !isEsimVisible) {
                quake.simulationTimeElapsed += dt_real * playSpeed;
                const elapsedSec = quake.simulationTimeElapsed;
                
                if (quake.firstObservationTime === null && elapsedSec >= quake.minPTime) {
                    quake.firstObservationTime = elapsedSec;
                    sysLogger.log('SIM', 'First observation detected. EEW 3-second silence period started.');
                }
                
                if (quake.firstObservationTime !== null && !quake.eewYellowTriggered) {
                    const timeSinceFirstObs = elapsedSec - quake.firstObservationTime;
                    if (timeSinceFirstObs >= 3.0) {
                        quake.eewYellowTriggered = true;
                        forecastWarnedPrefs.clear();
                        const count = stations.length; const dists = quake.cachedDists;
                        const forecastMag = Math.max(0, quake.mag - 1.15);
                        for(let i=0; i<count; i++) {
                            const st = stations[i]; if (!st.area) continue;
                            const distHypo = Math.sqrt(dists[i]*dists[i] + quake.depth*quake.depth);
                            const expectedInt = calculateIntensity(forecastMag, quake.depth, distHypo, st.amp, st.lat, st.lon, quake.lat, quake.lon, quake.strike, false, 0, st.avs);
                            if (expectedInt >= 3.5) forecastWarnedPrefs.add(st.area.name.replace(/\s+/g, ''));
                        }
                        sysLogger.log('SIM', 'EEW Yellow issued at 3 seconds (using M-1.3 forecast). Yellow map activated.');
                    }
                }
                
                if (quake.firstObservationTime !== null) {
                    const timeSinceFirstObs = elapsedSec - quake.firstObservationTime;
                    if (timeSinceFirstObs < 3.0) {
                        forecastWarnedPrefs.clear();
                    }
                }
                
                if (isPlumMapVisible && !isRegionIntMode) {
                    if (quake.firstObservationTime !== null) {
                        const timeSinceFirstObs = elapsedSec - quake.firstObservationTime;
                        if (timeSinceFirstObs >= 3.0) {
                            if (plumWarnedPrefs.size > 0) { ctx.fillStyle = "rgba(255, 100, 0, 0.6)"; plumWarnedPrefs.forEach(areaKey => { if (!forecastWarnedPrefs.has(areaKey)) { const path = prefPolygons[areaKey]; if (path) ctx.fill(path, 'evenodd'); } }); }
                            if (forecastWarnedPrefs.size > 0) { ctx.fillStyle = "rgba(255, 240, 0, 0.55)"; forecastWarnedPrefs.forEach(areaKey => { const path = prefPolygons[areaKey]; if (path) ctx.fill(path, 'evenodd'); }); }
                        }
                    }
                }
            }

            let pRad=0, sRad=0, surfRad=0; let maxIntObserved = 0; const stats = [0,0,0,0,0,0,0,0,0,0];
            
            if(quake && !isRealDataMode) {
                const elapsedSec = quake.simulationTimeElapsed;
                
                const baseScale = V_SIZE / 2400; 
                const baseLatRad = 36 * Math.PI / 180; 
                const currentLatRad = quake.lat * Math.PI / 180;
                const mercatorFactor = Math.cos(baseLatRad) / Math.cos(currentLatRad);
                const kmToPx = baseScale * mercatorFactor; 
                
                let avgVp = 6.0; let avgVs = 3.5;
                if (quake.depth > 30) { avgVp = 7.6; avgVs = 4.3; }

                pRad = (avgVp * elapsedSec) * kmToPx; sRad = (avgVs * elapsedSec) * kmToPx; surfRad = (V_SURF * elapsedSec) * kmToPx;
                
                if(!isUserInteracting) {
                    const minZoom = Math.min(width/V_SIZE, height/V_SIZE) * 0.9;
                    const waveZoom = Math.min(width, height) / (Math.max(100, pRad * 2.5));
                    targetCam.zoom = Math.max(minZoom, waveZoom);
                }
                
                const count = stations.length;
                const dists = quake.cachedDists;
                const pArrs = quake.cachedPArrivals;
                const sArrs = quake.cachedSArrivals;
                const tInts = quake.cachedTargetInts;
                
                for(let i=0; i<count; i++) {
                    const st = stations[i];
                    if (elapsedSec < pArrs[i]) continue; 
                    
                    const distKm = dists[i];
                    const targetInt = tInts[i];
                    let finalInt = 0;
                    
                    let durationBase = Math.pow(10, 0.3 * (quake.mag - 3.0)) + distKm * 0.05; 
                    if (st.amp > 1.4) durationBase *= 1.5;
                    const randomFactor = 1 + (st.rnd || (st.rnd = Math.random() - 0.5)) * 0.2; 
                    
                    if (elapsedSec < sArrs[i]) { 
                        const pPhase = (elapsedSec - pArrs[i]) / (Math.max(0.1, sArrs[i] - pArrs[i])); 
                        finalInt = targetInt * 0.45 * (0.5 + 0.5 * Math.sin(pPhase * Math.PI * 4)) * randomFactor; 
                    } else { 
                        const timeSinceS = elapsedSec - sArrs[i]; 
                        const peakHoldTime = (quake.mag > 6.0) ? (quake.mag - 5.0) * 3.0 : 0.5; 
                        if (timeSinceS < peakHoldTime) finalInt = targetInt * randomFactor; 
                        else finalInt = targetInt * Math.exp(-(timeSinceS - peakHoldTime) / (durationBase * 0.6)) * randomFactor; 
                        
                        if (quake.depth < 40 && distKm > 100) { 
                            const surfArr = distKm / V_SURF; 
                            if (elapsedSec > surfArr && elapsedSec < surfArr + 10) finalInt *= (1 + 0.2 * Math.sin((elapsedSec - surfArr) * Math.PI)); 
                        } 
                    }
                    
                    let limitedInt = applyShindoLimiter(finalInt); 
                    const smoothingFactor = Math.min(1.0, 0.2 * playSpeed); 
                    st.currentInt += (Math.max(0, limitedInt) - st.currentInt) * smoothingFactor; 
                    if (st.currentInt > st.maxInt) st.maxInt = st.currentInt;
                    if(st.currentInt > maxIntObserved) maxIntObserved = st.currentInt;


                }
                
                if (isSimQuakeRunning && simQuake) {
                    simQuake.simulationTimeElapsed += dt_real * playSpeed;
                    const sElapsed = simQuake.simulationTimeElapsed;
                    for(let i=0; i<stations.length; i++) {
                        const st = stations[i];
                        if (sElapsed < simQuake.cachedPArrivals[i]) continue;
                        const distKm = simQuake.cachedDists[i];
                        const targetInt = simQuake.cachedTargetInts[i];
                        let finalInt = 0;
                        let durationBase = Math.pow(10, 0.3 * (simQuake.mag - 3.0)) + distKm * 0.05;
                        if (st.amp > 1.4) durationBase *= 1.5;
                        const randomFactor = 1 + (st.rnd || (st.rnd = Math.random() - 0.5)) * 0.2;
                        if (sElapsed < simQuake.cachedSArrivals[i]) {
                            const pPhase = (sElapsed - simQuake.cachedPArrivals[i]) / Math.max(0.1, simQuake.cachedSArrivals[i] - simQuake.cachedPArrivals[i]);
                            finalInt = targetInt * 0.45 * (0.5 + 0.5 * Math.sin(pPhase * Math.PI * 4)) * randomFactor;
                        } else {
                            const timeSinceS = sElapsed - simQuake.cachedSArrivals[i];
                            const peakHoldTime = (simQuake.mag > 6.0) ? (simQuake.mag - 5.0) * 3.0 : 0.5;
                            if (timeSinceS < peakHoldTime) finalInt = targetInt * randomFactor;
                            else finalInt = targetInt * Math.exp(-(timeSinceS - peakHoldTime) / (durationBase * 0.6)) * randomFactor;
                        }
                        let limitedInt = applyShindoLimiter(finalInt);
                        st.simInt += (Math.max(0, limitedInt) - st.simInt) * Math.min(1.0, 0.2 * playSpeed);
                        if (st.simInt > st.simMaxInt) st.simMaxInt = st.simInt;
                    }
                }

                const elapsedSecPlum = quake.simulationTimeElapsed;
                if (quake.firstObservationTime !== null) {
                    const timeSinceFirstObs = elapsedSecPlum - quake.firstObservationTime;
                    let hasIntensity5Plus = false;
                    for (let st of stations) {
                        if (st.maxInt >= 4.5) {
                            hasIntensity5Plus = true;
                            break;
                        }
                    }
                    if (timeSinceFirstObs >= 3.0 && hasIntensity5Plus && !quake.plumTriggered) {
                        quake.plumTriggered = true;
                        quake.nextPlumUpdate = timeSinceFirstObs;
                        sysLogger.log('SIM', 'PLUM Warning Triggered (Intensity 5- detected)');
                    }
                    if (quake.plumTriggered && timeSinceFirstObs >= quake.nextPlumUpdate) {
                        plumWarnedPrefs.clear();
                        for (let checkSt of stations) {
                            if (checkSt.maxInt >= 3.5 && checkSt.area) {
                                const areaKey = checkSt.area.name.replace(/\s+/g, '');
                                plumWarnedPrefs.add(areaKey);
                                if (window.neighborMap && window.neighborMap.get(checkSt.code)) {
                                    const neighbors = window.neighborMap.get(checkSt.code);
                                    neighbors.forEach(nSt => { if(nSt.area) { const nKey = nSt.area.name.replace(/\s+/g, ''); plumWarnedPrefs.add(nKey); } });
                                }
                            }
                        }
                        quake.nextPlumUpdate = timeSinceFirstObs + 6.0;
                        if (plumWarnedPrefs.size > 0) {
                            sysLogger.log('SIM', 'PLUM areas updated (using max intensity): ' + plumWarnedPrefs.size + ' areas warned');
                        }
                    }
                }
                
                if (time - lastReportUpdate > 1000) { document.getElementById('report-content').innerHTML = generateReport(quake); lastReportUpdate = time; }
            } else if (isRealDataMode) { 
                if (isSimQuakeRunning && simQuake) {
                    simQuake.simulationTimeElapsed += dt_real * playSpeed;
                    const sElapsed = simQuake.simulationTimeElapsed;
                    for(let i=0; i<stations.length; i++) {
                        const st = stations[i];
                        if (sElapsed < simQuake.cachedPArrivals[i]) continue;
                        const distKm = simQuake.cachedDists[i];
                        const targetInt = simQuake.cachedTargetInts[i];
                        let finalInt = 0;
                        let durationBase = Math.pow(10, 0.3 * (simQuake.mag - 3.0)) + distKm * 0.05;
                        if (st.amp > 1.4) durationBase *= 1.5;
                        const randomFactor = 1 + (st.rnd || (st.rnd = Math.random() - 0.5)) * 0.2;
                        if (sElapsed < simQuake.cachedSArrivals[i]) {
                            const pPhase = (sElapsed - simQuake.cachedPArrivals[i]) / Math.max(0.1, simQuake.cachedSArrivals[i] - simQuake.cachedPArrivals[i]);
                            finalInt = targetInt * 0.45 * (0.5 + 0.5 * Math.sin(pPhase * Math.PI * 4)) * randomFactor;
                        } else {
                            const timeSinceS = sElapsed - simQuake.cachedSArrivals[i];
                            const peakHoldTime = (simQuake.mag > 6.0) ? (simQuake.mag - 5.0) * 3.0 : 0.5;
                            if (timeSinceS < peakHoldTime) finalInt = targetInt * randomFactor;
                            else finalInt = targetInt * Math.exp(-(timeSinceS - peakHoldTime) / (durationBase * 0.6)) * randomFactor;
                        }
                        let limitedInt = applyShindoLimiter(finalInt);
                        st.simInt += (Math.max(0, limitedInt) - st.simInt) * Math.min(1.0, 0.2 * playSpeed);
                        if (st.simInt > st.simMaxInt) st.simMaxInt = st.simInt;
                    }
                }
                for(let st of stations) if(st.currentInt > maxIntObserved) maxIntObserved = st.currentInt; 
            }

            const zoomBase = Math.max(3.5 / Math.sqrt(cam.zoom), 3.0 / cam.zoom); 
            hoveredStation = null;
            if(lastMousePos && isStationVisible) { const mPos = screenToVirtual(lastMousePos.x, lastMousePos.y); const hRad = 15/cam.zoom; for(let st of stations) { if(Math.abs(st.vx-mPos.x)<hRad && Math.abs(st.vy-mPos.y)<hRad) { hoveredStation = st; break; } } }
            
            const GRID_CELL_SIZE = 1.15;
            const cx = width / 2;
            const cy = height / 2;

            if (isRealDataMode || Math.abs(lastCamState.x - cam.x) > 0.1 || Math.abs(lastCamState.y - cam.y) > 0.1 || Math.abs(lastCamState.zoom - cam.zoom) > 0.01 || needsSort) {
                const candidates = [];
                if (isStationVisible) {
                    for(let i=0; i<stations.length; i++) {
                        const st = stations[i];
                        const sx = (st.vx - cam.x) * cam.zoom + cx;
                        const sy = (st.vy - cam.y) * cam.zoom + cy;
                        if(sx < -50 || sx > width*dpr + 50 || sy < -50 || sy > height*dpr + 50) continue;
                        
                        let val = (displayMode === 'real') ? st.currentInt : st.maxInt; 
                        if (isRealDataMode && comparisonMode === 1) val = (displayMode === 'real') ? st.simInt : st.simMaxInt;
                        
                        let sortKey = isAvsView ? -st.avs : val;
                        candidates.push({ st: st, val: val, sortKey: sortKey, sx: sx, sy: sy, absX: st.vx * cam.zoom, absY: st.vy * cam.zoom, index: i });
                    }
                }

                candidates.sort((a,b) => (b.sortKey - a.sortKey) || (b.index - a.index));

                const grid = new Set();
                const renderQueue = [];
                for(let i=0; i<candidates.length; i++) {
                    const c = candidates[i];
                    const key = Math.floor(c.absX / GRID_CELL_SIZE) + "," + Math.floor(c.absY / GRID_CELL_SIZE);
                    if(!grid.has(key)) { grid.add(key); renderQueue.push(c); }
                }
                cachedRenderQueue = renderQueue.reverse();
                lastCamState = { x: cam.x, y: cam.y, zoom: cam.zoom };
                needsSort = false;
            }

            const renderQueue = cachedRenderQueue;
            if (isStationVisible) {
                stats.fill(0);
                for(let item of renderQueue) {
                    const st = item.st;
                    let val = (displayMode === 'real') ? st.currentInt : st.maxInt; 
                    if (isRealDataMode && comparisonMode === 1) val = (displayMode === 'real') ? st.simInt : st.simMaxInt;
                    item.val = val; 
                    if(val >= 0.5) stats[Math.min(9, Math.floor(val + 0.5))]++;
                }
            }

            if(quake) {
                if (!isRealDataMode) {
                    ctx.lineWidth = 2.0/cam.zoom; ctx.strokeStyle = 'rgba(0,180,255,0.4)'; ctx.beginPath(); ctx.arc(quake.vx, quake.vy, pRad, 0, Math.PI*2); ctx.stroke();
                    ctx.lineWidth = 3.0/cam.zoom; ctx.strokeStyle = 'rgba(255,80,80,0.5)'; ctx.beginPath(); ctx.arc(quake.vx, quake.vy, sRad, 0, Math.PI*2); ctx.stroke();
                    if (quake.depth < 60) { ctx.lineWidth = 4.0/cam.zoom; ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)'; ctx.beginPath(); ctx.arc(quake.vx, quake.vy, surfRad, 0, Math.PI*2); ctx.stroke(); }
                    if(quake.isFault) { ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)'; ctx.lineWidth = 4/cam.zoom; ctx.beginPath(); ctx.moveTo(quake.fX1, quake.fY1); ctx.lineTo(quake.fX2, quake.fY2); ctx.stroke(); const rDist = Math.min(quake.fLengthKm, quake.simulationTimeElapsed * (3.5 * RUPTURE_RATIO)); if(rDist > 0 && quake.ruptureDur > 0) { ctx.fillStyle = '#ffeb3b'; const fwd = Math.min((1-quake.rRatio)*quake.fLengthKm, rDist), bwd = Math.min(quake.rRatio*quake.fLengthKm, rDist); if(fwd>0){ const p=fwd/((1-quake.rRatio)*quake.fLengthKm); ctx.beginPath(); ctx.arc(quake.vx+(quake.fX2-quake.vx)*p, quake.vy+(quake.fY2-quake.vy)*p, 5/cam.zoom, 0, Math.PI*2); ctx.fill(); } if(bwd>0){ const p=bwd/(quake.rRatio*quake.fLengthKm); ctx.beginPath(); ctx.arc(quake.vx+(quake.fX1-quake.vx)*p, quake.vy+(quake.fY1-quake.vy)*p, 5/cam.zoom, 0, Math.PI*2); ctx.fill(); } } }
                }
                const cSize = 10/cam.zoom; ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 3/cam.zoom; ctx.beginPath(); ctx.moveTo(quake.vx-cSize, quake.vy-cSize); ctx.lineTo(quake.vx+cSize, quake.vy+cSize); ctx.moveTo(quake.vx+cSize, quake.vy-cSize); ctx.lineTo(quake.vx-cSize, quake.vy+cSize); ctx.stroke();
            }

            if (isAvsView) {
                 for(let item of renderQueue) {
                    let st = item.st; ctx.fillStyle = getAVSColor(st.avs); 
                    let size = Math.max(2.0, 5.0/cam.zoom); 
                    if(isStationCircle) { ctx.beginPath(); ctx.arc(st.vx, st.vy, size/2, 0, Math.PI*2); ctx.fill(); } 
                    else { ctx.fillRect(st.vx - size/2, st.vy - size/2, size, size); }
                 }
            } else if (isRealDataMode && comparisonMode === 2) {
                 for(let item of renderQueue) {
                    const st = item.st;
                    const simVal = st.simMaxInt || 0;
                    const realVal = st.currentInt || 0;
                    const size = (simVal >= 0.1 || realVal >= 0.1) ? zoomBase * 3.3 : zoomBase;
                    if (simVal < 0.1 && realVal < 0.1) {
                        ctx.fillStyle = 'rgba(255,255,255,0.08)';
                        ctx.beginPath(); ctx.arc(st.vx, st.vy, size/2, 0, Math.PI*2); ctx.fill();
                    } else {
                        ctx.fillStyle = getIntColor(simVal);
                        ctx.beginPath(); ctx.moveTo(st.vx, st.vy); ctx.arc(st.vx, st.vy, size/2, Math.PI/2, Math.PI*1.5); ctx.closePath(); ctx.fill();
                        ctx.fillStyle = getIntColor(realVal);
                        ctx.beginPath(); ctx.moveTo(st.vx, st.vy); ctx.arc(st.vx, st.vy, size/2, -Math.PI/2, Math.PI/2); ctx.closePath(); ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 0.5 / cam.zoom;
                        ctx.beginPath(); ctx.moveTo(st.vx, st.vy - size/2); ctx.lineTo(st.vx, st.vy + size/2); ctx.stroke();
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 0.5 / cam.zoom;
                        ctx.beginPath(); ctx.arc(st.vx, st.vy, size/2, 0, Math.PI*2); ctx.stroke();
                    }
                 }
            } else if (isRealDataMode && comparisonMode === 3) {
                 for(let item of renderQueue) {
                    const st = item.st;
                    const simVal = st.simMaxInt || 0;
                    const realVal = st.currentInt || 0;
                    const size = (simVal >= 0.1 || realVal >= 0.1) ? zoomBase * 3.3 : zoomBase;
                    if (simVal < 0.1 && realVal < 0.1) {
                        ctx.fillStyle = 'rgba(255,255,255,0.08)';
                        ctx.beginPath(); ctx.arc(st.vx, st.vy, size/2, 0, Math.PI*2); ctx.fill();
                    } else {
                        const simLv = getIntLevel(simVal);
                        const realLv = getIntLevel(realVal);
                        const diff = simLv - realLv;
                        if (diff < 0) {
                            const absDiff = Math.abs(diff);
                            if (absDiff === 1) ctx.fillStyle = '#00aaff';
                            else if (absDiff === 2) ctx.fillStyle = '#0066ff';
                            else if (absDiff === 3) ctx.fillStyle = '#0000ff';
                            else ctx.fillStyle = '#000080';
                        } else {
                            ctx.fillStyle = getLevelColor(Math.abs(diff));
                        }
                        ctx.beginPath(); ctx.arc(st.vx, st.vy, size/2, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 0.5 / cam.zoom;
                        ctx.beginPath(); ctx.arc(st.vx, st.vy, size/2, 0, Math.PI*2); ctx.stroke();
                        if (diff < 0) {
                            ctx.fillStyle = "#fff";
                        } else {
                            ctx.fillStyle = (Math.abs(diff) >= 1 && Math.abs(diff) < 5) ? "#000" : "#fff";
                        }
                        ctx.font = `900 ${size * 0.55}px "Roboto"`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                        ctx.fillText((diff >= 0 ? "+" : "") + diff, st.vx, st.vy + size*0.05);
                    }
                 }
            } else {
                 ctx.fillStyle = 'rgba(255,255,255,0.08)'; 
                 for(let item of renderQueue) {
                     if (item.val < 0.1) {
                         const size0 = zoomBase; const size0_2 = size0 / 2;
                         if(isStationCircle) { ctx.beginPath(); ctx.moveTo(item.st.vx + size0_2, item.st.vy); ctx.arc(item.st.vx, item.st.vy, size0_2, 0, Math.PI*2); ctx.fill(); } 
                         else { ctx.fillRect(item.st.vx - size0_2, item.st.vy - size0_2, size0, size0); }
                     }
                 }
                 for(let item of renderQueue) {
                     if (item.val >= 0.1) {
                        let st = item.st; let val = item.val;
                        let color = '#555'; let size = zoomBase * 2.5; 
                        if (val >= 0.5) { color = getIntColor(val); size = zoomBase * 3.3; } 
                        ctx.fillStyle = color; const size_2 = size / 2;
                        if(isStationCircle) { ctx.beginPath(); ctx.arc(st.vx, st.vy, size_2, 0, Math.PI*2); ctx.fill(); } 
                        else { ctx.fillRect(st.vx - size_2, st.vy - size_2, size, size); }
                        if(val >= 0.5) { 
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 0.5 / cam.zoom; 
                            if(isStationCircle) { ctx.beginPath(); ctx.arc(st.vx, st.vy, size_2, 0, Math.PI*2); ctx.stroke(); } 
                            else { ctx.strokeRect(st.vx - size_2, st.vy - size_2, size, size); }
                            ctx.fillStyle = (val >= 0.5 && val < 4.5) ? "#000" : "#fff"; 
                            ctx.font = `900 ${size * 0.65}px "Roboto"`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; 
                            if (isIntNumberVisible) {
                                ctx.fillText(getIntStr(val), st.vx, st.vy + size*0.05);
                            } 
                        }
                     }
                 }
            }
            
            let targetSt = selectedStation || hoveredStation;
            if(targetSt && isStationVisible) { 
                const s = targetSt; const boxX = s.vx; const boxY = s.vy - 45/cam.zoom; let val = (displayMode === 'real') ? s.currentInt : s.maxInt; 
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1/cam.zoom; ctx.beginPath(); ctx.moveTo(s.vx, s.vy); ctx.lineTo(boxX, boxY + 15/cam.zoom); ctx.stroke(); 
                ctx.shadowColor="black"; ctx.shadowBlur=4; ctx.fillStyle = "#fff"; ctx.font = `bold ${14/cam.zoom}px "Oswald"`; ctx.textAlign = "center"; ctx.textBaseline = "bottom"; 
                let label = s.name; if(s.pref) label = `${s.pref.name} ${s.city.name} ${s.name}`; ctx.fillText(label, boxX, boxY); 
                ctx.shadowBlur=2; ctx.font = `bold ${10/cam.zoom}px "Roboto Mono"`; ctx.fillStyle = "#ccc";
                let infoLine1 = `ARV:${s.amp.toFixed(2)}  AVS:${Math.round(s.avs)}`; ctx.fillText(infoLine1, boxX, boxY + 12/cam.zoom);
                let infoLine2 = `TCODE:${s.tcode || 'N/A'}`; ctx.fillText(infoLine2, boxX, boxY + 23/cam.zoom);
                if (!isAvsView) { ctx.shadowBlur=4; ctx.font = `bold ${18/cam.zoom}px "Oswald"`; ctx.fillStyle = getIntColor(val); ctx.fillText(`INT: ${val.toFixed(1)}`, boxX, boxY - 18/cam.zoom); }
                ctx.shadowBlur=0; ctx.strokeStyle = '#00aaff'; ctx.lineWidth = 2/cam.zoom; ctx.strokeRect(s.vx-8/cam.zoom, s.vy-8/cam.zoom, 16/cam.zoom, 16/cam.zoom); 
            }
            
            if (isRegionIntMode) {
                regionIconAreas = [];
                const baseSize = 32;
                const scaleFactor = Math.min(1.2, Math.max(0.4, cam.zoom * 0.9)); 
                const iconSize = baseSize * scaleFactor;
                const sortedRegions = Array.from(regionMaxInts.entries()).sort((a, b) => a[1].maxInt - b[1].maxInt);
                sortedRegions.forEach(([key, r]) => {
                    const center = regionCenters.get(key);
                    if (center) {
                        if (isRegionIconVisible) {
                            regionIconAreas.push({ vx: center.vx, vy: center.vy, size: iconSize, name: r.name, int: r.maxInt });
                            ctx.save(); 
                            ctx.translate(center.vx, center.vy);
                            const drawSize = iconSize / cam.zoom;
                            ctx.fillStyle = getIntColor(r.maxInt); ctx.beginPath();
                            const r_rad = (6 * scaleFactor) / cam.zoom; 
                            ctx.moveTo(-drawSize/2 + r_rad, -drawSize/2); ctx.lineTo(drawSize/2 - r_rad, -drawSize/2); ctx.quadraticCurveTo(drawSize/2, -drawSize/2, drawSize/2, -drawSize/2 + r_rad); ctx.lineTo(drawSize/2, drawSize/2 - r_rad); ctx.quadraticCurveTo(drawSize/2, drawSize/2, drawSize/2 - r_rad, drawSize/2); ctx.lineTo(-drawSize/2 + r_rad, drawSize/2); ctx.quadraticCurveTo(-drawSize/2, drawSize/2, -drawSize/2, drawSize/2 - r_rad); ctx.lineTo(-drawSize/2, -drawSize/2 + r_rad); ctx.quadraticCurveTo(-drawSize/2, -drawSize/2, -drawSize/2 + r_rad, -drawSize/2); ctx.fill();
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5 / cam.zoom; ctx.stroke();
                            ctx.fillStyle = (r.maxInt < 4.5) ? '#000' : '#fff'; ctx.font = `900 ${drawSize * 0.7}px "Roboto"`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(getIntStr(r.maxInt), 0, 0);
                            ctx.restore();
                        }
                    }
                });
            }

            ctx.restore(); 
            if(quake && !isRealDataMode) { 
                if(frameCount % 10 === 0 && !isRealDataMode) { let html = ''; const labels = ["0","1","2","3","4","5-","5+","6-","6+","7"]; for(let i=9; i>=1; i--) { if(stats[i] > 0) { const c = getIntColor(i); html += `<div class="stat-row"><div class="stat-badge" style="background:${c}">${labels[i]}</div><div class="stat-count">${stats[i]}</div></div>`; } } statPanel.innerHTML = html; } 
            }
            document.getElementById('clock').innerText = new Date().toLocaleTimeString('ja-JP', {hour12:false}); 
            requestAnimationFrame(loop);
        }

        let isUserInteracting = false, evCache = [], prevDiff = -1, isDragging = false, dragStart = {x:0, y:0}, lastMousePos = null;
        function manualZoom(f) { isUserInteracting = true; targetCam.zoom *= f; if(targetCam.zoom < 0.1) targetCam.zoom = 0.1; if(targetCam.zoom > 50) targetCam.zoom = 50; }
        function screenToVirtual(sx, sy) { return { x: (sx - width/2) / cam.zoom + cam.x, y: (sy - height/2) / cam.zoom + cam.y }; }
        function resetCamera() { targetCam.x = V_SIZE/2; targetCam.y = V_SIZE/2; targetCam.zoom = Math.min(width/V_SIZE, height/V_SIZE) * 0.9; }

        canvas.addEventListener('pointerdown', (e) => { initAudio(); evCache.push(e); isDragging = false; dragStart = { x: e.clientX, y: e.clientY }; isUserInteracting = true; });
        canvas.addEventListener('pointermove', (e) => { lastMousePos = {x: e.clientX, y: e.clientY}; const index = evCache.findIndex((c) => c.pointerId === e.pointerId); if (index >= 0) evCache[index] = e; if(!isDragging && evCache.length > 0) { if(Math.sqrt((e.clientX - dragStart.x)**2 + (e.clientY - dragStart.y)**2) > 5) isDragging = true; } if (evCache.length === 1 && isDragging) { targetCam.x -= e.movementX / cam.zoom; targetCam.y -= e.movementY / cam.zoom; } if (evCache.length === 2) { const curDiff = Math.hypot(evCache[0].clientX - evCache[1].clientX, evCache[0].clientY - evCache[1].clientY); if (prevDiff > 0) { targetCam.zoom *= (1 + (curDiff - prevDiff) * 0.005); if(targetCam.zoom < 0.1) targetCam.zoom = 0.1; if(targetCam.zoom > 50) targetCam.zoom = 50; } prevDiff = curDiff; } });
        canvas.addEventListener('pointerup', (e) => {
            const index = evCache.findIndex((c) => c.pointerId === e.pointerId); if (index >= 0) evCache.splice(index, 1); if (evCache.length < 2) prevDiff = -1;
            if (!isDragging) {
                if (isRegionIntMode) {
                    const v = screenToVirtual(e.clientX, e.clientY);
                    let found = false;
                    for (let i = regionIconAreas.length - 1; i >= 0; i--) { 
                        const r = regionIconAreas[i];
                        const hitRadius = (r.size / 2) / cam.zoom;
                        if (Math.abs(v.x - r.vx) <= hitRadius && Math.abs(v.y - r.vy) <= hitRadius) { 
                            document.getElementById('pop-name').innerText = r.name; 
                            const valEl = document.getElementById('pop-int-val'); 
                            valEl.innerText = getIntStr(r.int); 
                            valEl.style.background = getIntColor(r.int); 
                            document.getElementById('region-popup').style.display = 'flex'; 
                            found = true; break;
                        } 
                    }
                    if (!found) document.getElementById('region-popup').style.display = 'none';
                    if (found) return;
                }
                const v = screenToVirtual(e.clientX, e.clientY); const g = toGeo(v.x, v.y); let clickedStation = null; const clickRadius = 15 / cam.zoom;
                if (isStationVisible) { for(let st of stations) { if(Math.abs(st.vx - v.x) < clickRadius && Math.abs(st.vy - v.y) < clickRadius) { clickedStation = st; break; } } }
                if (clickedStation) { selectedStation = clickedStation; isUserInteracting = true; } 
                else if (v.x > -500 && v.x < V_SIZE+500 && v.y > -500 && v.y < V_SIZE+500 && !isRealDataMode) { 
                    selectedStation = null; isUserInteracting = true; guideOverlay.classList.add('hidden'); 
                    setTimeout(() => { startQuake(g.lat, g.lon, parseFloat(magIn.value), parseInt(depIn.value), parseFloat(rupIn.value)); }, 0);
                }
            }
        });
        canvas.addEventListener('wheel', (e) => { e.preventDefault(); isUserInteracting = true; targetCam.zoom *= (e.deltaY > 0 ? 0.9 : 1.1); if(targetCam.zoom < 0.1) targetCam.zoom = 0.1; if(targetCam.zoom > 50) targetCam.zoom = 50; }, { passive: false });
        
        const compass = document.getElementById('compass-ring'), needle = document.getElementById('compass-needle'); let isDraggingCompass = false;
        compass.addEventListener('pointerdown', (e) => { isDraggingCompass = true; updateCompassFromEvent(e); e.stopPropagation(); e.preventDefault(); });
        window.addEventListener('pointermove', (e) => { if (isDraggingCompass) { updateCompassFromEvent(e); e.preventDefault(); } });
        window.addEventListener('pointerup', () => { isDraggingCompass = false; });
        function updateCompassFromEvent(e) { const rect = compass.getBoundingClientRect(); const angle = Math.atan2(e.clientY - (rect.top + rect.height/2), e.clientX - (rect.left + rect.width/2)) * 180 / Math.PI; let strike = angle + 90; if (strike < 0) strike += 360; strike = Math.round(strike / 5) * 5; setStrike(strike); }
        function setStrike(val) { currentStrike = val; needle.style.transform = `translate(-50%, -50%) rotate(${val}deg)`; document.getElementById('d-str').innerText = val + "°"; }
        function setDisplayMode(mode) { displayMode = mode; document.getElementById('btn-mode-max').classList.remove('active'); document.getElementById('btn-mode-real').classList.remove('active'); if(mode === 'max') document.getElementById('btn-mode-max').classList.add('active'); else document.getElementById('btn-mode-real').classList.add('active'); }
        
        function switchTab(tabName) {
            if (tabName !== 'sim') { const targetBtn = document.getElementById('btn-' + tabName); if (targetBtn && targetBtn.classList.contains('active')) { switchTab('sim'); return; } }
            const btns = document.querySelectorAll('.nav-btn'); btns.forEach(b => b.classList.remove('active'));
            if(tabName === 'sim') document.getElementById('btn-sim').classList.add('active');
            if(tabName === 'real') document.getElementById('btn-real').classList.add('active');
            if(tabName === 'presets') document.getElementById('btn-presets').classList.add('active');
            if(tabName === 'settings') document.getElementById('btn-settings').classList.add('active');
            if(tabName === 'report') document.getElementById('btn-report').classList.add('active');

            if(tabName === 'sim') { menuContainer.classList.remove('visible'); } 
            else { 
                menuContainer.classList.add('visible'); 
                viewPresets.classList.remove('active-view'); 
                viewSettings.classList.remove('active-view'); 
                viewReal.classList.remove('active-view'); 
                viewReport.classList.remove('active-view');
                viewStructure.classList.remove('active-view');

                if(tabName === 'presets') viewPresets.classList.add('active-view'); 
                else if(tabName === 'real') { viewReal.classList.add('active-view'); if(fullRealDataList.length===0) fetchRealData(false); } 
                else if(tabName === 'settings') viewSettings.classList.add('active-view'); 
                else if(tabName === 'report') viewReport.classList.add('active-view');
                else if(tabName === 'structure') viewStructure.classList.add('active-view');
            }
        }
        
        async function fetchRealData(append) {
            const listEl = document.getElementById('real-data-list');
            if(!append) { listEl.innerHTML = '<div style="text-align:center; padding:20px;">LOADING JMA DATA...</div>'; fullRealDataList = []; realDataOffset = 0; btnMore.style.display = 'none'; } else { btnMore.innerText = "LOADING..."; }
            sysLogger.log('NET', 'Fetching JMA data from P2PQuake API...');
            try {
                const response = await fetch(`https://api.p2pquake.net/v2/history?codes=551&limit=${realDataLimit}&offset=${realDataOffset}`);
                const data = await response.json();
                if (data.length > 0) { 
                    fullRealDataList = fullRealDataList.concat(data); realDataOffset += data.length; filterRealData(); 
                    sysLogger.log('NET', `Received ${data.length} records.`);
                    if (data.length < realDataLimit) btnMore.style.display = 'none'; else { btnMore.style.display = 'block'; btnMore.innerHTML = '<svg viewBox="0 0 24 24" style="width:14px; height:14px; margin-right:6px; fill:none; stroke:currentColor; stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round; vertical-align:middle;"><path d="M7 13l5 5 5-5M7 6l5 5 5-5"></path></svg>LOAD OLDER (+50)'; } 
                } else { 
                    if(!append) listEl.innerHTML = '<div style="text-align:center; color:#888; padding:20px;">NO DATA FOUND</div>'; btnMore.style.display = 'none'; 
                    sysLogger.log('NET', 'No data found.');
                }
            } catch (e) { 
                listEl.innerHTML = '<div style="text-align:center; color:#ff4444; padding:20px;">FAILED TO FETCH DATA<br>Check internet connection</div>'; 
                sysLogger.error('E-NET-001', `Fetch Error: ${e.message}`, e);
            }
        }
        function filterRealData() {
            needsSort = true;
            const regionInput = document.getElementById('filter-region').value.toLowerCase().trim();
            const minMagInput = parseFloat(document.getElementById('filter-mag').value) || 0;
            const sortType = document.getElementById('sort-type').value;

            if (realDataSubMode === 'api') {
                if (fullRealDataList.length === 0) return;
                filteredRealDataList = fullRealDataList.filter(item => {
                    const hypo = item.earthquake.hypocenter;
                    return (hypo.name||"").toLowerCase().includes(regionInput) && (hypo.magnitude!==-1?hypo.magnitude:0) >= minMagInput;
                });
                filteredRealDataList.sort((a, b) => {
                    if (sortType === 'mag') return b.earthquake.hypocenter.magnitude - a.earthquake.hypocenter.magnitude;
                    else if (sortType === 'int') return b.earthquake.maxScale - a.earthquake.maxScale;
                    else return b.earthquake.time.localeCompare(a.earthquake.time);
                });
                renderRealDataList(filteredRealDataList);
            } else {
                if (fullHistoryData.length === 0) {
                    document.getElementById('real-data-list').innerHTML = '<div style="text-align:center; color:#666; padding:20px;">JSONを読み込んで履歴を表示</div>';
                    return;
                }
                let filtered = fullHistoryData.filter(item => {
                    const info = item.earthquake_info;
                    return info.hypocenter.toLowerCase().includes(regionInput) && info.magnitude >= minMagInput;
                });
                filtered.sort((a, b) => {
                    const infoA = a.earthquake_info;
                    const infoB = b.earthquake_info;
                    if (sortType === 'mag') return infoB.magnitude - infoA.magnitude;
                    else if (sortType === 'int') return parseIntensity(infoB.max_intensity) - parseIntensity(infoA.max_intensity);
                    else return (infoB.date + " " + infoB.time).localeCompare(infoA.date + " " + infoA.time);
                });
                renderHistoryList(filtered);
            }
        }

        function setRealDataSubMode(mode) {
            needsSort = true;
            realDataSubMode = mode;
            document.getElementById('btn-mode-api').classList.toggle('active', mode === 'api');
            document.getElementById('btn-mode-history').classList.toggle('active', mode === 'history');
            document.getElementById('api-controls').style.display = (mode === 'api' ? 'block' : 'none');
            document.getElementById('history-controls').style.display = (mode === 'history' ? 'block' : 'none');
            filterRealData();
        }

        function loadHistoryFile(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    fullHistoryData = Array.isArray(data) ? data : [data];
                    sysLogger.log('FILE', `履歴データをロードしました: ${fullHistoryData.length}件`);
                    filterRealData();
                    // Hide history load button on success
                    const historyBtn = document.getElementById('btn-load-history-file');
                    if(historyBtn) historyBtn.style.display = 'none';
                } catch (err) {
                    sysLogger.error('E-FILE-005', '履歴JSONのパースに失敗しました', err);
                }
            };
            reader.readAsText(file);
        }

        function parseDMS(dmsStr) {
            if (!dmsStr) return 0;
            const match = dmsStr.match(/(\d+)°([\d.]+)′/);
            if (!match) return parseFloat(dmsStr) || 0;
            return parseInt(match[1]) + parseFloat(match[2]) / 60;
        }

        function parseIntensity(intStr) {
            const map = { "震度１": 1.0, "震度２": 2.0, "震度３": 3.0, "震度４": 4.0, "震度５弱": 4.7, "震度５強": 5.2, "震度６弱": 5.7, "震度６強": 6.2, "震度７": 7.0 };
            return map[intStr] || 0;
        }

        function findStation(prefName, stationName) {
            let found = stations.find(s => s.name === stationName);
            if (found) return found;
            const norm = (s) => s.replace(/（旧）/g, '').replace(/\s+/g, '').replace(/ヶ/g, 'ケ');
            const normStationName = norm(stationName);
            found = stations.find(s => norm(s.name) === normStationName);
            if (found) return found;
            found = stations.find(s => {
                if (!s.pref || s.pref.name !== prefName) return false;
                return s.name.includes(stationName) || stationName.includes(s.name);
            });
            return found;
        }

        function renderHistoryList(data) {
            const listEl = document.getElementById('real-data-list');
            listEl.innerHTML = '';
            data.forEach(item => {
                const info = item.earthquake_info;
                const maxIntVal = parseIntensity(info.max_intensity);
                const div = document.createElement('div');
                div.className = 'real-item';
                div.innerHTML = `<div class="real-info"><div class="real-place">${info.hypocenter}</div><div class="real-time">${info.date} ${info.time} / Depth: ${info.depth}</div></div><div class="real-mag">M${info.magnitude.toFixed(1)}</div><div class="real-max-int" style="background:${getIntColor(maxIntVal)}">${getIntStr(maxIntVal)}</div>`;
                div.onclick = () => loadHistoryEvent(item);
                listEl.appendChild(div);
            });
        }

        function loadHistoryEvent(item) {
            needsSort = true;
            resetSim();
            isRealDataMode = true;
            const info = item.earthquake_info;
            const lat = parseDMS(info.latitude);
            const lon = parseDMS(info.longitude);
            const depth = parseInt(info.depth);
            const v = toVirtual(lon, lat);
            quake = { lat, lon, vx: v.x, vy: v.y, mag: info.magnitude, depth: depth, strike: 0, startTime: 0, simulationTimeElapsed: 0, isFault: false, displayMag: info.magnitude, displayDep: depth };
            if (item.observations) {
                item.observations.forEach(obs => {
                    const intVal = parseIntensity(obs.intensity);
                    const st = findStation(obs.prefecture, obs.station);
                    if (st) { st.currentInt = intVal; st.maxInt = intVal; }
                });
            }
            targetCam.x = v.x; targetCam.y = v.y; targetCam.zoom = 2.0;
            ibRegion.innerText = info.hypocenter; ibDepth.innerText = depth + "km"; ibMag.innerText = "M" + info.magnitude.toFixed(1);
            statPanel.style.display = 'block';
            document.getElementById('report-content').innerHTML = generateReport(quake);
            switchTab('sim');
            document.getElementById('esim-control').style.display = 'flex';
            comparisonMode = 0; isSimQuakeRunning = false; simQuake = null;
            const btnComp = document.getElementById('btn-comparison');
            btnComp.style.display = 'block';
            btnComp.innerText = 'SIMULATE THIS EVENT';
            btnComp.style.background = 'rgba(0, 170, 255, 0.8)';
            btnComp.style.color = '#fff';
            
            // Restore original multi-mode toggle
            window.toggleComparisonMode = function() {
                needsSort = true;
                if (!isRealDataMode || !quake) return;
                comparisonMode = (comparisonMode + 1) % 4;
                const btn = document.getElementById('btn-comparison');
                if (comparisonMode === 1) {
                    btn.innerText = 'MODE: SIMULATION';
                    btn.style.background = 'rgba(255, 80, 80, 0.8)';
                    btn.style.color = '#fff';
                    if (!isSimQuakeRunning) startSimQuakeFromReal();
                } else if (comparisonMode === 2) {
                    btn.innerText = 'MODE: HALF & HALF';
                    btn.style.background = 'rgba(255, 215, 0, 0.8)';
                    btn.style.color = '#000';
                } else if (comparisonMode === 3) {
                    btn.innerText = 'MODE: ERROR COMP';
                    btn.style.background = 'rgba(0, 255, 128, 0.8)';
                    btn.style.color = '#000';
                } else {
                    btn.innerText = 'SIMULATE THIS EVENT';
                    btn.style.background = 'rgba(0, 170, 255, 0.8)';
                    btn.style.color = '#fff';
                }
            };
            sysLogger.log('SIM', `History Event Loaded: ${info.hypocenter} (${info.date})`);
        }
        function renderRealDataList(data) {
            const listEl = document.getElementById('real-data-list'); listEl.innerHTML = '';
            if (data.length === 0) { listEl.innerHTML = '<div style="text-align:center; color:#888; padding:20px;">NO DATA MATCHES FILTER</div>'; return; }
            const convertJMAScale = (s) => { if(s===10)return 1;if(s===20)return 2;if(s===30)return 3;if(s===40)return 4;if(s===45)return 5;if(s===50)return 5.5;if(s===55)return 6;if(s===60)return 6.5;if(s===70)return 7;return 0; };
            data.forEach((item) => {
                const originalIndex = fullRealDataList.indexOf(item); const hypo = item.earthquake.hypocenter; const timeStr = item.earthquake.time.replace(/:00$/, ''); const mag = hypo.magnitude !== -1 ? "M"+hypo.magnitude.toFixed(1) : "---"; const maxInt = convertJMAScale(item.earthquake.maxScale);
                const div = document.createElement('div'); div.className = 'real-item';
                div.innerHTML = `<div class="real-info"><div class="real-place">${hypo.name}</div><div class="real-time">${timeStr} / Depth: ${hypo.depth}km</div></div><div class="real-mag">${mag}</div><div class="real-max-int" style="background:${getIntColor(maxInt)}">${getIntStr(maxInt)}</div>`;
                div.onclick = () => {
                    const data = fullRealDataList[originalIndex]; if(!data) return;
                    resetSim(); isRealDataMode = true; 
                    const hypo = data.earthquake.hypocenter; const lat = hypo.latitude === -1 ? 0 : hypo.latitude; const lon = hypo.longitude === -1 ? 0 : hypo.longitude;
                    const v = toVirtual(lon, lat);

                    const baseScale = V_SIZE / 2400; 
                    const baseLatRad = 36 * Math.PI / 180;
                    const currentLatRad = lat * Math.PI / 180;
                    const mercatorFactor = Math.cos(baseLatRad) / Math.cos(currentLatRad);
                    const localKmToPx = baseScale * mercatorFactor;

                    quake = { lat, lon, vx: v.x, vy: v.y, mag: hypo.magnitude, depth: hypo.depth, strike: 0, startTime: 0, simulationTimeElapsed: 0, isFault: false, displayMag: hypo.magnitude, displayDep: hypo.depth };
                    
                    let maxIntObserved = 0;
                    if(data.points) { data.points.forEach(p => { const intVal = convertJMAScale(p.scale); stations.forEach(st => { if (p.addr.indexOf(st.name)!==-1 || st.name.indexOf(p.addr)!==-1) { if(intVal > st.currentInt) st.currentInt = intVal; st.maxInt = st.currentInt; } }); if(intVal > maxIntObserved) maxIntObserved = intVal; }); }
                    if(lat !== 0) { targetCam.x = v.x; targetCam.y = v.y; targetCam.zoom = 2.0; }
                    
                    ibRegion.innerText = hypo.name; ibDepth.innerText = hypo.depth + "km"; ibMag.innerText = "M" + (hypo.magnitude !== -1 ? hypo.magnitude.toFixed(1) : "---"); infoBar.className = "";
                    statPanel.style.display = 'block'; document.getElementById('report-content').innerHTML = generateReport(quake); switchTab('sim'); guideOverlay.classList.add('hidden'); document.getElementById('esim-control').style.display = 'flex'; esimGenerated = false; isEsimVisible = false; document.getElementById('btn-toggle-esim').innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 3v18h18M7 16l4-4 4 4 5-8"></path></svg><span>推計震度分布</span>';
                    comparisonMode = 0; isSimQuakeRunning = false; simQuake = null;
                    document.getElementById('btn-comparison').style.display = 'block';
                    document.getElementById('btn-comparison').innerText = 'SIMULATE THIS EVENT';
                    sysLogger.log('SIM', `Real Data Loaded: ${hypo.name} (M${hypo.magnitude})`);
                };
                listEl.appendChild(div);
            });
        }
        window.addEventListener('resize', () => { width = window.innerWidth; height = window.innerHeight; initMap(); });
        
        async function autoLoadEmbeddedData() {
            try {
                sysLogger.log('SYS', 'Auto-loading Map data...');
                const res = await fetch('japan.geo.json'); 
                if (res.ok) {
                    const data = await res.json();
                    processGeoJSON(data);
                    // Hide map button on success
                    document.getElementById('btn-load-map').style.display = 'none';
                } else {
                    sysLogger.error('E-FILE-001', 'japan.geo.json NOT FOUND');
                }
            } catch (err) {
                sysLogger.error('E-FILE-001', 'Map load failed', err);
            }

            try {
                sysLogger.log('SYS', 'Auto-loading Station data...');
                const res = await fetch('stations_with_amp_revised.json');
                if (res.ok) {
                    const data = await res.json();
                    processStationData(data);
                    // Hide station button on success
                    document.getElementById('btn-load-station').style.display = 'none';
                } else {
                    sysLogger.error('E-FILE-003', 'stations_with_amp_revised.json NOT FOUND');
                }
            } catch (err) {
                sysLogger.error('E-FILE-003', 'Station load failed', err);
            }

            try {
                sysLogger.log('SYS', 'Auto-loading Epicenter data...');
                const res = await fetch('震央地名.geo.json');
                if (res.ok) {
                    const data = await res.json();
                    epicenterFeatures = data.features || (data.type === 'FeatureCollection' ? data.features : [data]);
                    // Hide epicenter button on success
                    document.getElementById('btn-load-epicenter').style.display = 'none';
                    sysLogger.log('SYS', `Epicenter data loaded: ${epicenterFeatures.length}`);
                }
            } catch (err) {
                sysLogger.log('SYS', 'Epicenter data skipped or not found.');
            }

            try {
                const historyFileName = 'jma_all_quakes.json'; 
                sysLogger.log('SYS', `Attempting to auto-load external history: ${historyFileName}`);
                const response = await fetch(historyFileName);
                if (response.ok) {
                    const historyData = await response.json();
                    if (Array.isArray(historyData) && historyData.length > 0) {
                        sysLogger.log('SYS', `Successfully auto-loaded external history (${historyData.length} events)`);
                        fullHistoryData = historyData;
                        setRealDataSubMode('history');
                        filterRealData();
                        
                        // Hide history load button on success
                        const historyBtn = document.getElementById('btn-load-history-file');
                        if(historyBtn) historyBtn.style.display = 'none';
                    }
                } else {
                    sysLogger.log('SYS', `External history file not found: ${historyFileName}`);
                }
            } catch (err) {
                sysLogger.log('SYS', `External history auto-load skipped: ${err.message}`);
            }
        }

        function showStructureManual() {
            document.getElementById('structure-content').innerText = STRUCTURE_MANUAL_TEXT;
            switchTab('structure');
        }

        function toggleLogMonitor() {
            const overlay = document.getElementById('log-overlay');
            if (overlay.style.display === 'flex') {
                overlay.style.display = 'none';
            } else {
                overlay.style.display = 'flex';
                const content = document.getElementById('log-content');
                content.scrollTop = content.scrollHeight;
            }
        }

        const logWindowState = {
            isDragging: false,
            isResizing: false,
            resizeDirection: null,
            initialMouseX: 0,
            initialMouseY: 0,
            initialLogX: 0,
            initialLogY: 0,
            initialLogWidth: 0,
            initialLogHeight: 0,
            pointerId: null
        };

        const MIN_LOG_WIDTH = 280;
        const MIN_LOG_HEIGHT = 140;

        function clampLogPosition() {
            const overlay = document.getElementById('log-overlay');
            const rect = overlay.getBoundingClientRect();
            let left = rect.left;
            let top = rect.top;
            const width = rect.width;
            const height = rect.height;

            if (left < 0) left = 0;
            if (top < 0) top = 0;
            if (left + width > window.innerWidth) left = window.innerWidth - width;
            if (top + height > window.innerHeight - 65) top = window.innerHeight - height - 65;

            overlay.style.left = left + 'px';
            overlay.style.top = top + 'px';
        }

        const logHeader = document.getElementById('log-header');
        
        logHeader.addEventListener('pointerdown', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            logWindowState.isDragging = true;
            logWindowState.initialMouseX = e.clientX;
            logWindowState.initialMouseY = e.clientY;
            const overlay = document.getElementById('log-overlay');
            const rect = overlay.getBoundingClientRect();
            logWindowState.initialLogX = rect.left;
            logWindowState.initialLogY = rect.top;
            logWindowState.pointerId = e.pointerId;
            logHeader.setPointerCapture(e.pointerId);
            e.stopPropagation();
        });

        logHeader.addEventListener('pointermove', (e) => {
            if (!logWindowState.isDragging) return;
            const deltaX = e.clientX - logWindowState.initialMouseX;
            const deltaY = e.clientY - logWindowState.initialMouseY;
            const overlay = document.getElementById('log-overlay');
            const newLeft = logWindowState.initialLogX + deltaX;
            const newTop = logWindowState.initialLogY + deltaY;
            overlay.style.left = newLeft + 'px';
            overlay.style.top = newTop + 'px';
            clampLogPosition();
        });

        logHeader.addEventListener('pointerup', (e) => {
            if (logWindowState.isDragging) {
                logWindowState.isDragging = false;
                logHeader.releasePointerCapture(logWindowState.pointerId);
            }
        });

        const resizeHandles = {
            'top': 'n',
            'bottom': 's',
            'left': 'w',
            'right': 'e',
            'top-left': 'nw',
            'top-right': 'ne',
            'bottom-left': 'sw',
            'bottom-right': 'se'
        };

        Object.entries(resizeHandles).forEach(([handleId, direction]) => {
            const handle = document.getElementById('log-resize-handle-' + handleId);
            if (!handle) return;

            handle.addEventListener('pointerdown', (e) => {
                logWindowState.isResizing = true;
                logWindowState.resizeDirection = direction;
                logWindowState.initialMouseX = e.clientX;
                logWindowState.initialMouseY = e.clientY;
                const overlay = document.getElementById('log-overlay');
                const rect = overlay.getBoundingClientRect();
                logWindowState.initialLogX = rect.left;
                logWindowState.initialLogY = rect.top;
                logWindowState.initialLogWidth = rect.width;
                logWindowState.initialLogHeight = rect.height;
                logWindowState.pointerId = e.pointerId;
                handle.setPointerCapture(e.pointerId);
                e.stopPropagation();
            });
        });

        window.addEventListener('pointermove', (e) => {
            if (!logWindowState.isResizing) return;

            const overlay = document.getElementById('log-overlay');
            const deltaX = e.clientX - logWindowState.initialMouseX;
            const deltaY = e.clientY - logWindowState.initialMouseY;
            const dir = logWindowState.resizeDirection;

            let newLeft = logWindowState.initialLogX;
            let newTop = logWindowState.initialLogY;
            let newWidth = logWindowState.initialLogWidth;
            let newHeight = logWindowState.initialLogHeight;

            if (dir.includes('w')) {
                newWidth = logWindowState.initialLogWidth - deltaX;
                newLeft = logWindowState.initialLogX + deltaX;
            } else if (dir.includes('e')) {
                newWidth = logWindowState.initialLogWidth + deltaX;
            }

            if (dir.includes('n')) {
                newHeight = logWindowState.initialLogHeight - deltaY;
                newTop = logWindowState.initialLogY + deltaY;
            } else if (dir.includes('s')) {
                newHeight = logWindowState.initialLogHeight + deltaY;
            }

            if (newWidth < MIN_LOG_WIDTH) {
                newWidth = MIN_LOG_WIDTH;
                if (dir.includes('w')) newLeft = logWindowState.initialLogX + (logWindowState.initialLogWidth - MIN_LOG_WIDTH);
            }
            if (newHeight < MIN_LOG_HEIGHT) {
                newHeight = MIN_LOG_HEIGHT;
                if (dir.includes('n')) newTop = logWindowState.initialLogY + (logWindowState.initialLogHeight - MIN_LOG_HEIGHT);
            }

            if (newLeft < 0) {
                newWidth += newLeft;
                newLeft = 0;
            }
            if (newTop < 0) {
                newHeight += newTop;
                newTop = 0;
            }
            if (newLeft + newWidth > window.innerWidth) {
                newWidth = window.innerWidth - newLeft;
            }
            if (newTop + newHeight > window.innerHeight - 65) {
                newHeight = window.innerHeight - 65 - newTop;
            }

            overlay.style.left = newLeft + 'px';
            overlay.style.top = newTop + 'px';
            overlay.style.width = newWidth + 'px';
            overlay.style.height = newHeight + 'px';
        });

        window.addEventListener('pointerup', (e) => {
            if (logWindowState.isResizing) {
                logWindowState.isResizing = false;
                const handle = document.querySelector('[id^="log-resize-handle"]');
                if (handle && logWindowState.pointerId) {
                    try {
                        handle.releasePointerCapture(logWindowState.pointerId);
                    } catch (err) {
                    }
                }
            }
        });

        window.addEventListener('resize', () => {
            clampLogPosition();
        });
        
        // -------------------------------------------------------------
        // ドキュメント初期化・エントリポイント
        // -------------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => { 
            sysLogger.init(); 
            width = window.innerWidth; height = window.innerHeight; 
            setTimeout(() => { autoLoadEmbeddedData(); initMap(); setTimeout(() => { const loading = document.getElementById('loading'); if(loading && loading.style.display !== 'none') loading.style.display = 'none'; }, 1000); }, 500); 
        });
        window.draw = function() { };

        // Expose auto-load function for manual triggering if needed
        window.autoLoadEmbeddedData = autoLoadEmbeddedData;

        // Manual Text Constant
        const STRUCTURE_MANUAL_TEXT = `============================================================================
EQS v34.4 (Auto-Load & Fix) コード完全構造解析書
============================================================================
[更新履歴]
- 自動ファイル読み込み (Auto-Load) 機能を強化
- ファイル名検索ロジックを修正 (カッコ付きファイル名の回避)
============================================================================`;
    </script>
</html>
